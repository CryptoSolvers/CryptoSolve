\documentclass{easychair}
%\documentclass[11pt,twoside,a4paper]{article}
\usepackage{amssymb, amsthm}
\usepackage{proof}
\usepackage{url}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{latexsym, graphics, graphicx}
\usepackage{color}
\usepackage{epsfig, amssymb}
\usepackage{yfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{float}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{marginnote}
\usepackage{mathtools}
\usepackage{todonotes}
\usepackage{fancyhdr}


\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{corol}{Corollary}
\newtheorem{proprt}{Property}
\newtheorem{lemma}{Lemma}
\newtheorem{restn}{Restriction}
\newtheorem{modif}{Modification}
\newtheorem{assumption}{Assumption}

\newcommand{\pa}{{\bf Pair}}
\newcommand{\enc}{{\bf Enc}}
\newcommand{\eq}{\mathcal{EQ}}
\newcommand{\bphi}{\ovr{\phi}}
\newcommand{\bh}{\ovr{h}}
\newcommand{\tdh}{\tilde{h}}
\newcommand{\ignore}[1]{}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\CSU}[1]{\mathit{CSU_{#1}}}

%\newcommand{\ISFULL}

\ifdefined\ISFULL
\newcommand{\FULL}[1]{#1}
\newcommand{\SHORT}[1]{}
\else
\newcommand{\FULL}[1]{}
\newcommand{\SHORT}[1]{#1}
\fi



\title{Algorithmic Problems in the Symbolic Approach to the Verification of Automatically Synthesized Cryptosystems}

\author{Andrew M. Marshall \inst{1} 
	\and Catherine A. Meadows \inst{2} 
	\and Paliath Narendran \inst{3} 
	\and Veena Ravishankar \inst{1} 
	\and Brandon Rozek \inst{4} }
\institute{University of Mary Washington, Fredericksburg, VA, USA
	\and Naval Research Laboratory, Washington, DC, USA
	\and University at Albany--SUNY, Albany, NY, USA 
	\and Naval Surface Warfare Center Dahlgren Division, Dahlgren, VA, USA}

\authorrunning{Marshall, Meadows, Narendran, Ravishankar, and Rozek}
\titlerunning{MOE Decision Problems}
\begin{document}
%\tableofcontents
\maketitle
\begin{abstract}
We investigate two algorithmic problems that arise in the Symbolic Approach to the Verification of Automatically Synthesized Cryptosystems. First, we investigate several forms of
the decision problem which arises in the symbolic investigation 
of cryptographic Modes of Encryption (MOE). We present several
undecidability results for these problems. Second, we investigate
the invertability problem which also arises in investigation of
MOE.    

\end{abstract}


%\pagebreak

\section{Introduction}
A relatively new and promising direction in the verification of
automatically synthesized cryptosystems is to utilize previously developed methods from the analysis of cryptographic protocols 
(for example~\cite{malozemoff2014automated}).
In particular, we follow an approach developed here [cite Cathy paper].
In this approach we can model synthesized cryptographic algorithms
as a type of protocol modeling the interaction between an adversary
and an encryptor/oracle. We denote these protocols as 
MOE-programs, see Definition~\ref{def:moe_program}.
In this model the adversary sends messages to the oracle which then 
encrypts those messages according to some pre-determined 
method. The encrypted blocks are then send back to the adversary 
based on some schedule. One can then reduce certain security
questions on the overall synthesized cryptographic algorithm to
the adversary being able to equationally unifiy cipher blocks
it obtains from the oracle, see [Cathy paper] for more details
and underlying security proofs. We are therefore, very interested 
in the class of algorithmic questions that ask whether there exists
an algorithm to decide if given a MOE-program and schedule, can
the adversary always find a unifier if one exists. The most basic form
of this question, where the numeric length and number of independent protocol 
interactions is finitely bounded has been proven decidable for the
$xor$-equational theory [cite Chris and Hai's paper]. 
Here we investigate the remaining cases and show them undecidable.

A related algorithmic question asks if given a MOE-term and assuming
the encryption can be inverted (decrypted), can one unwind the 
encryption and other function applications to retrieve the 
original message. This ``invertability'' property of course 
is usually a requirement for any useful cryptographic algorithm.
It is therefore important to know if an aromatically generated cryptosystem has this property. We investigate the following algorithmic 
question of given a MOE-program and schedule: is there an algorithm that will decide if the produced cipher blocks are invertible or not?
   
 
\section{Preliminaries}
Let us briefly introduce some of the background concepts which will be important to this paper. 
\subsection{Terms and Substitutions}
Given a first-order signature $\Sigma$, a set of {\em names} is a
countable set of (free) constants $N$, such that $\Sigma \cap N =
\emptyset$.  Given a (countable) set of variables $X$, the set of
$(\Sigma \cup N)$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$.
The set of variables in a term $t$ is denoted by $fv(t)$ and the set
of names in $t$ is denoted by $fn(t)$.  A term $t$ is \emph{ground} if
$fv(t) = \emptyset$.  For any position $p$ in a term $t$ (including
the root position $\epsilon$), $t(p)$ denotes the symbol at position
$p$, $t|_p$ denotes the subterm of $t$ at position $p$, and $t[u]_p$
denotes the term $t$ in which $t|_p$ is replaced by $u$.
The size of a term $t$ is denoted by $|t|$ and defined in the usual
way as follows: $|f(t_1,\dots,t_n)| = 1 + \sum_{i=1}^n |t_i|$ if $f$
is a $n$-ary function symbol with $n\geq 1$, $|c| = 1$ if $c \in N$, and $|x| = 0$ if $x \in X$.
A substitution $\sigma$ is an endomorphism of $T(\Sigma \cup N,X)$ with only finitely many variables not mapped to themselves, denoted by
$\sigma= \{ x_1 \mapsto t_1, \dots, x_m \mapsto t_m \}$. 
Application of a substitution $\sigma$ to a term $t$ is written $t\sigma$.
Given two substitutions $\theta$ and $\sigma$, the composition $\sigma \circ \theta$ is the substitution denoted here by $\theta\sigma$ and defined such that $x(\theta\sigma) = (x\theta)\sigma$ for any $x \in X$. 
The domain of $\sigma$ is $Dom(\sigma) = \{ x \in X ~|~ x\sigma \neq x \}$. The range of $\sigma$ is $Ran(\sigma) = \{ x\sigma ~|~ x \in Dom(\sigma) \}$. When $\theta$ and $\sigma$ are two substitutions with disjoint domains and only ground terms in their ranges, then $\theta\sigma = \theta \cup \sigma$.
Given a substitution $\sigma$ and a finite set of variables $V \subseteq X$, the restriction of $\sigma$ to $V$ is the substitution denoted by $\sigma_{| V}$ such that $x\sigma_{| V} = x \sigma$ for any $x \in V$ and $x\sigma_{| V} = x$ for any $x \in X \backslash V$.

\subsection{Equational Theories}

Given a set $E$ of $\Sigma$-axioms (i.e., pairs of $\Sigma$-terms,
denoted by $l = r$), the \emph{equational theory} $=_E$ is the
congruence closure of $E$ under the law of substitutivity.  For any
$\Sigma$-term $t$, the equivalence class of $t$ with respect to $=_E$
is denoted by $[t]_E$. Since $\Sigma \cap N = \emptyset$, the 
$\Sigma$-equalities in $E$ do not contain any names in $N$.
A theory $E$ is
\emph{trivial} if $x=_E y$, for two distinct variables $x$ and $y$. In this
paper, all the considered theories are assumed non-trivial.

An $E$-unification problem with free constants in $N$ is a set of $\Sigma \cup N$-equations $P= \{ s_{1} =^{?} t_{1} , \dots , s_{m} =^{?} t_{m}\} $.
The set of variables in
$P$ is denoted by $fv(P)$.  A solution to $P$, called an
\emph{E-unifier\/}, is a substitution $\sigma$ such that $s_i \sigma
=_E^{} t_i \sigma$ for all $1 \leq i \leq m$.  A substitution $\sigma$
is \emph{more general modulo\/} $E$ than $\theta$ on a set of
variables $V$, denoted as $\sigma \leq_{E}^V \theta$, if there is a
substitution $\tau$ such that $x \sigma \tau =_{E} x \theta$ for all
$x \in V$.  A \emph{Complete Set of $E$-Unifiers} of $P$, denoted by
$\CSU{E}(P)$, is a set of substitutions such that each $\sigma \in
\CSU{E}(P)$ is an $E$-unifier of $P$, and for each $E$-unifier
$\theta$ of $P$, there exists $\sigma \in \CSU{E}(P)$ such that
$\sigma \leq_{E}^{fv(P)} \theta$.  $E$-unification is said to be
\emph{finitary} if any $E$-unification problem $P$ admits a finite
$\CSU{E}(P)$.  An $E$-unification problem $P = \{ x_{1} =^{?} t_{1} , \dots , x_{m} =^{?} t_{m}\}$ is a {\em solved form}
if  $x_1,\dots, x_m$ are variables occurring once in $P$, and in that
case the corresponding substitution $\mu_P = \{ x_{1} \mapsto t_{1} ,
\dots , x_{m} \mapsto t_{m} \}$ is an $E$-unifier of $P$ such that $\{ \mu_P \}$ is a $\CSU{E}(P)$.
When $E$ is empty, $E$-unification is called syntactic unification and
has the property of being unitary: if two terms $s$ and $t$ are
syntactically unifiable, then there exists a $\CSU{E}(s =^? t)$ of cardinality $1$ whose element is called a most general unifier of $s =^? t$ denoted by $mgu(s,t)$.


\subsection{Modes of Encryption}

\begin{definition}
	$MOE$-terms: Given a first-order signature $\Sigma$, a countable set of (free) constants (names) $N$, such that $\Sigma \cap N =\emptyset$, and a (countable) set of variables $X$, the set of $MOE$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$. 
\end{definition}



\begin{definition}\label{def:moe_program}
	$MOE$-Program: Is an interaction between the 
	the adversary and the oracle consisting of the following actions
	and orders. Let $c$ be a name representing a session identifier.
	\begin{enumerate}
		\item $start(c)$. The start of a session $c$, sent from the
		adversary to oracle.
		\item $stop(c)$. The end of session $c$.
		\item $block(c, x)$. A new block in session $c$ sent from
		the adversary to the oracle. This is to be encrypted by the 
		oracle. This variable, $x$, represents possible messages, via
		instantiation, that the adversary could send during a program
		run. 
		\item $send(c, m)$. The oracle send a $MOE$-term, $m$, back
		to the adversary. The variables of $m$ must have been 
		previously contained in a received $block(c, x)$ message
		that occurred before the $send(c, m)$ message.
	\end{enumerate} 
\end{definition}
This ordering in the last item will be important to the decision 
problems. We can more compactly represent the sequence of messages
in a $MOE$-program as a frame. 

\begin{definition}
	$MOE_{\oplus}$-terms: Given a first-order signature $\Sigma=\{
	\oplus, 0, f, h\}$, a countable set of (free) constants (names) $N$, such that $\Sigma \cap N =\emptyset$, and a (countable) set of variables $X$, the set of $MOE_{\oplus}$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$. 
\end{definition}

\begin{definition}
		$MOE$-frame:  $\phi = \nu \tilde{n}.\sigma$, where
		$\tilde{n}$ is a set of names representing non-free variables such as random nonces. $\sigma$ is a substitution
		such that $Dom(\sigma) = \{ y_1, y_2, \ldots, y_n\}$,
		$Dom(\sigma) \cap \tilde{n} = \emptyset$, and
		$Ran(\sigma)$ are $MOE$-terms.  
\end{definition}

A $MOE$-frame models a trace of a $MOE$ program in the following way:
if the $i$th action of the challenger in the trace of a given session $c$ is 
$block(c, t)$ or $send(c, t)$, where $t$ is a $MOE$-term, 
then there is a variable $y_i \in Dom(\sigma)$ and 
$y_i \sigma \mapsto t$. Random variables such as the IV are 
modeled as names and placed in $\tilde{n}$.

The terms of the frame are further restricted depending on the mode of encryption being modeled and the schedule used by the oracle to
return cipher blocks to the adversary. These restrictions have
the following impact on the $MOE$-frames:
\begin{itemize}
	\item $MOE$: The mode of encryption dictates how the oracle 
	constructs cipher blocks. For example, in a Cipher Block Chaining,
	$CBC$, $MOE$ the ith block of cipher text, $C_i$, is modeled by
	the $y_i \mapsto f(C_{i-1} \oplus x_i)$, where $\oplus$ is
	the xor function.
	\item Schedule: The oracle can either return the 
	cipher blocks immediately or at the end of the session.  
\end{itemize}

The adversary has the ability to execute multiple simultaneous sessions with the oracle. In this case the initial name, the IV, will be fresh for each session. Each session can then be modeled by it's own frame. 


%\begin{definition}
%	Let 
%\end{definition}


We model a potential attack via a decision problem involving unification. First we need a new definition of unification which includes the 
constraint on term orders imposed by the $MOE$-program. This 
ordering can be enforced using a relation $\prec_{\mathcal{P}}$, defined 
as follows. 

\begin{definition}
	Let $\mathcal{P}$ be a $MOE$-program and $\phi = \nu \tilde{n}.\sigma$ the corresponding frame. We define a relation, 
	$\prec_{\mathcal{P}}$, by:
	\begin{itemize}
		\item $t \prec_{\mathcal{P}} x$,
		$y_i \mapsto x, ~y_j \mapsto t ~ \in \sigma$, and
		$ i < j$.
		\item $x_i \prec_{\mathcal{P}} x_j$ iff 
		 $y_i \mapsto x_i, ~y_j \mapsto x_j ~ \in \sigma$, and
		 $ i < j$.
		 \item If $\bar{t} \prec_{\mathcal{P}} x$, then 
		 $f(\bar{t}) \prec_{\mathcal{P}} x$, where $f \in \Sigma$.
		 \item $t \not \prec_{\mathcal{P}} x$ iff $t \prec_{\mathcal{P}} x$ does not hold.
	\end{itemize}
\end{definition}

We can now define the $MOE$ unification problem.

\begin{definition}
	Let $\mathcal{P}$ be a $MOE$-program and $\phi = \nu \tilde{n}.\sigma$ the corresponding frame. Let $t_1$ and $t_2$
	be two $MOE$-terms appearing in $\mathcal{P}$. $t_1$ and $t_2$
	are $\mathcal{P}$-unifiable iff there exists some substitution
	$\delta$ s.t.
	\begin{itemize}
		\item $\forall x \in Dom(\delta), ~x\delta \prec_{\mathcal{P}} x$.
		\item $t_1 \delta =_E t_2\delta$.
	\end{itemize}
\end{definition}

We are interested in the problem of deciding if the adversary is able to $\mathcal{P}$-unify two cipher blocks. We can define several instances of the problem based on the combination of the following factors:
\begin{itemize}
	\item The equational Theory $E$.
	\item The $MOE$.
	\item The Schedule.
	\item Bounds on the session length and number of sessions.  
\end{itemize}

Here we will consider $\Sigma ={\oplus, 0, f, IV}$, where $\oplus$ is xor and $f=enc(K,\_)$, $IV$ is an initialization vector.
Several examples of $MOE$ using this signature are: 
\begin{itemize}
	\item Cipher Block Chaining $(CBC):$ The ith plain text is modeled via a term consisting of a single variable $x_i$. The initial cipher block, the IV, is modeled by a name, $r$. The ith block of cipher text, $C_i$, is modeled by a
	term $f(C_{i-1} \oplus x_i)$.
	\item Cipher Feedback $(CFB):$ The ith plain text is modeled via a term consisting of a single variable $x_i$. The initial cipher block is modeled by a name, $r$. The ith block of cipher text, $C_i$, is modeled by a
	term $f(C_{i-1}) \oplus x_i$.  
	\item Propagating Cipher Block Chaining ($PCBC$): 
	$C_1 = f(P_1 \oplus IV)$, $C_i = f(P_i \oplus P_{i-1} \oplus C_{i-1})$.
\end{itemize}



\section{Decision Problems with Unbounded Session Length in MOE-Programs}

The first type of decision problems we examine are those 
with sessions of an arbitrary or unbounded length. However,
we assume that the number of sessions is bounded. In both
cases, a bound of one on the number of sessions is stiff
sufficient to obtain the undecidability results. We examine two cases:
\begin{enumerate}
	\item The non-deterministic case: where the MOE program is modeled by a non-deterministic function. 
	See Section~\ref{sec:UB-non-det-func}.
	\item The deterministic case: where the MOE program is
	modeled as a deterministic function. 
	See Section~\ref{sec:UB-det-func}.
\end{enumerate}

\subsection{Non-deterministic Decision Problem in unbounded session lengths}\label{sec:UB-non-det-func}

In this section we prove that the non-deterministic version 
of the decision problem for MOE programs of 
unbounded session lengths and bounded number of sessions is undecidable.

\begin{definition}
If $A_i$ be a string such that $A_i = a_0 a_1\ldots a_m$ and 
$C_j$ some cipher block, let $F(A_i \bigoplus C_j) =
f(a_0 \oplus f(a_1 \oplus \ldots f(a_m \oplus C_j) \ldots ))$
\end{definition}

\begin{example}
Assume you have a string A = ``abd'' and assume $C$ is some cipher
block. Then, 
\[F(A \bigoplus C) = 
f(a \oplus f(b \oplus f(d \oplus C)))
\]
\end{example}



\begin{definition}\label{non-det-func}
Let $PCP = ~(\frac{A_0}{B_0}), ~(\frac{A_1}{B_1}), ~\ldots, ~(\frac{A_n}{B_n})$. 	
	
Let $C_i$ be the ith output of the cryptosystem. 
For $i > 0$ let $C_i = E_{i_0}$ or, $E_{i_2}$, or $\ldots$,
$E_{i_n}$ where 
\begin{align*}
	E_{i_j} &= [f(r_i \oplus C_{i, 1}), f(r_i \oplus C_{i,2}) ] \\
	C_{i,1} &= F(A_j \bigoplus C_{i-1, 1})	\\
	C_{i,2} &= F(B_j \bigoplus C_{i-1, 2}) 
\end{align*}
where $r_i$ is a new random nonce.
$C_0 = [r,r]$ for a nonce $r$
\end{definition}

Notice that Definition~\ref{non-det-func} defines a 
particle $MOE_{\oplus}$ and thus we can consider the problem 
of finding an algorithm that solves the decision problem for
this $MOE$. That is, an algorithm that will determine if 
the $MOE$ will ever produce two $\mathcal{P}$-unifiable
cipher blocks.

Based on the the non-deterministic system of 
Definition~\ref{non-det-func} we can define the following
$MOE_{\oplus}$ program which produces an unsafe pair, 
two $\mathcal{P}$-unifiable cipherblocks, iff the adversary
finds a solution to the PCP.

\begin{definition}
Denote the following $MOE$ program as $PCP_{MOE}$.
The program works as follows:
\begin{itemize}
	\item The adversary non-deterministically picks a possible
	solution to the PCP, $i_0, i_1, i_2, \ldots, i_k$.
	\item Each turn the adversary sends an index in the solution, 
	starting with $i_k$ and proceeding each turn until $i_0$ 
	is reached. 
	\item The oracle encodes a pair of cipher blocks according 
	to Definition~\ref{non-det-func} and returns the pair,
	$E_j$, to the adversary.
	\item The adversary attempts to $\mathcal{P}$-unify 
	all of the current cipher blocks it knows. 
	\item The program stops if the adversary finds an unsafe
	pair or it sends a stop session command.
\end{itemize}
\end{definition}

\begin{lemma}\label{lemma:pcp_to_moe}
Given a PCP problem the corresponding $PCP_{MOE}$ program 
produces a $\mathcal{P}$-unifiable pair of cipher blocks
iff there is a solution the given PCP. 
\end{lemma}
\begin{proof}
Follows from the encoding given in Definition~\ref{non-det-func}
\end{proof}



\begin{theorem}
	Assume $M$ is an arbitrary $MOE_{\oplus}$. The problem
	of determining if $M$, executing with 
	a bounded number of sessions and unbounded session
	lengths, ever produces two  $\mathcal{P}$-unifiable cipher blocks is undecidable. 
\end{theorem}
\begin{proof}
	Assume there was such an algorithm. Then one could apply that
	algorithm to the $MOE_{\oplus}$ defined in
	Definition~\ref{non-det-func}. However, 
	from Lemma~\ref{lemma:pcp_to_moe}, this would
	imply that we could then solve the PCP, a contradiction.   
\end{proof}

\begin{example}
	Consider the following PCP:
	\[
	(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
	\] 
	A solution to this problem is $1,3$. 
	
	Let's trace a run of the $PCP_{MOE}$ program where the 
	adversary guesses the solution $1,3$.
	\begin{enumerate}
		\item In the first step the adversary sends $3$ to the
		oracle and receives the following cipher block in return.
		$C_1 = E_{1_3}$ where
		\begin{align*}
		E_{1_3} &= [f(r_1 \oplus C_{1, 1}), f(r_1 \oplus C_{1,2}) ] \\
		C_{1,1} &= F(A_3 \bigoplus C_{0, 1}) = 
		(f(a \oplus f(a \oplus f(a \oplus IV))))	\\
		C_{1,2} &= F(B_3 \bigoplus C_{0, 2}) =
		f(a \oplus f(a \oplus IV))
		\end{align*}
		\item At the second step the adversary send a $1$ to the
		oracle and receives the following in return.
		$C_2 = E_{2_1}$ where
		\begin{align*}
		E_{2_1} &= [f(r_2 \oplus C_{2, 1}), f(r_2, C_{2,2}) ] \\
		C_{2,1} &= F(A_1 \bigoplus C_{1, 1}) = 
		f(b \oplus f(a \oplus C_{1,1}))	\\
		C_{2,2} &= F(B_1 \bigoplus C_{1, 2}) =
		f(b \oplus f(a \oplus f(a \oplus C_{1,2})))
		\end{align*}
	\end{enumerate}
	Notice that now after step 2 the adversary has two 
	cipher blocks, $C_{2,1}$ and $C_{2,2}$, which are
	$\mathcal{P}$-unifiable.
	
\begin{align*}
C_{2,1} &= f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus IV))))) \\
C_{2,2} &= f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus IV)))))
\end{align*}

\end{example}


\subsection{Deterministic Decision Problem in unbounded session lengths}\label{sec:UB-det-func}
In this section we create a deterministic version of the 
above non-deterministic program by testing not a single 
non-deterministic selected solution but rather all possible
solutions. This then allows us to prove the undecidability
of the deterministic decision problem for MOE programs 
with unbounded session lengths and bounded number of sessions. 

\begin{definition}\label{det-func}
	
	Let $PCP = ~(\frac{A_0}{B_0}), ~(\frac{A_1}{B_1}), ~\ldots, ~(\frac{A_n}{B_n})$. 	
	
	Let $O_i$ be the ith output of the cryptosystem. 
	For $i > 0$ let $O_i = [E_{i_{0,0}}$, $E_{i_{0,1}}$, $\ldots$,
	$E_{i_{n,m}}]$ where $m = |O_{i-1}|$ and for 
	$0 \leq j \leq n$ and $0 \leq l \leq m$
	\begin{align*}
	E_{i_{j,k}} &= [f(r_p \oplus C_{i, 1}), f(r_p, C_{i,2}) ] \\
	C_{i_{j,k},1} &= F(A_j \bigoplus C_{i-1_{k}, 1})	\\
	C_{i_{j,k},2} &= F(B_j \bigoplus C_{i-1_{k}, 2}) 
	\end{align*}
	where $r_p$ is a new random nonce.
	$C_0 = [r,r]$ for a nonce $r$
\end{definition}
 
The program works as follows:
\begin{itemize}
	\item For each step $i$, $0 \leq i \leq M$, the adversary
	sends $i$.
	\item The oracle encodes all combinations of PCP blocks
	of length, $i$, according to Definition~\ref{det-func}.
	The oracle sends the list of cipher blocks back to
	the adversary.
	\item The adversary attempts to $\mathcal{P}$-unify 
	all of the current cipher blocks it knows.
	\item The session stops if an unsafe pair is found or 
	the adversary sends the stop command. 
\end{itemize}

\begin{theorem}
	Assume $M$ is an arbitrary $MOE_{\oplus}$. The problem
	of determining if $M$, executing with 
	a bounded number of sessions and unbounded session
	lengths, ever produces two  $\mathcal{P}$-unifiable cipher blocks is undecidable. 
\end{theorem}
\begin{proof}
	Notice that if there is a finite sequence giving a solution
	to the PCP at some finite number of steps that sequence will
	be produced and the adversary will find an unsafe pair.  
\end{proof}


\ignore{
\subsection{Option Two: Create a new session for each possible
	encoding}


The program works as follows:
\begin{itemize}
	\item Start with a single session with $C_0 = [r,r]$
	\item For each step $i > 0$, the adversary creates
	a new session for each of the possible strings of length 
	$i$. In each session it sends the previous cipher block, $C_k$, and a index $j$.
	\item The oracle encodes the blocks, $F(A_j \bigoplus C_{k, 1})$ and $F(B_j \bigoplus C_{K, 2})$ and sends them back
	to the adversary.
	\item The adversary attempts to $\mathcal{P}$-unify 
	the blocks it knows. 
	\item The program ends if an unsafe pair is found or 
	the stop command is sent by the adversary.  
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 				Old part of the paper                        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Decision Problems with an Adversary Encoding the PCP}
In this section we assume that the adversary is active and the 
oracle is passive. That is, the adversary attempts to encode the 
PCP problem strings and find unifiers. The oracle only applies the 
$f()$ function and returns cypher blocks to the adversary. 

First we explore possible string encoding methods, depending on
the existence of a hash functions $h()$, which the adversary 
could use to encode the PCP.

\subsection{String Encoding Methods}\label{sec:encoding}
Consider an arbitrary PCP problem:
\[
(\frac{A_1}{B_1}),~(\frac{A_2}{B_2}), ~\ldots, ~(\frac{A_n}{B_n})
\]
over an alphabet $\Sigma=\{a, b\}$. 
\ignore{
	%%%OLD DEF
	We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
	setting each character of the string as a plaintext block 
	and sending each to the oracle from left to right, one at a 
	time. For example,  $A_i = a_1 a_2 a_3 a_4$:
	\begin{align*}
	p_1 &=a_1\\
	c_1 &=f(a_1 \oplus IV)\\
	p_2 &=a_2\\
	c_2 &=f(a_2 \oplus c_1)\\
	&\ldots\\
	c_4 &=f(a_4 \oplus c_3)
	\end{align*}
	%%%End of Old Def
}

\subsubsection{String Encodings with a $h()$ function}
The first method for encoding strings assumes we have a
hash function, $h()$, which can be used to enforce 
positions of characters in the strings. 
We encode a string $A_i = a_1 a_2 a_3 a_4$ by 
first using repeated applications of $h()$ to first encode
the position of that character in the string. For example,
$h^1(a_1), ~h^2(a_2), ~h^3(a_3), h^4(a_4)$.
We then combine each character in the string via $\oplus$,
$h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4)$. 


\subsubsection{String Index and Cypher Block Encoding}

For example, consider the string ``$a_1a_2a_3a_4$'' and assume
this string is contained in the ith block of the CPC problem.
We then introduce a new nonce $r_i$ which will be added to ensure
only strings with the same index can be unified. 
The encoding is done as follows:
\begin{itemize}
	\item $p_1 = 0$
	\item $c_1 = f(0 \oplus IV) = f(IV)$. 
	Note, that this cypher block is 
	not unifiable with any other due to the unique IV.
	\item $p_2 = r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4) \oplus c_1$
	\item $c_2 = f(r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4) \oplus c_1 \oplus c_1) = 
	f(r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4))$. 
\end{itemize} 


\subsubsection{Chaining Multiple String}
Suppose we want to now encode the new string $A_1 A_3$.
This encoding can be done as follows:
\begin{itemize}
	\item Encode the character positions using $h()$ in
	$A_1$ concatenated with $A_2$. 
	Denote these as $h(A_1A_3)$
	respectively. 
	\item Create a sessions, and remove the initial IV.
	\item Encode the string into a cypher block and add 
	a new nonce the represents the index $1,3$, denotes this
	nonce as $r_{13}$.
	\begin{itemize}
		\item $p_2= r_{1,3} \oplus h(A_1 A_3) \oplus c_1$
		\item $c_2 = f(r_{1,3} \oplus h(A_1 A_3))$
	\end{itemize} 
\end{itemize}

\subsubsection{Encoding all Possible Permutations}
We now have all the tools needed to encode the possible 
strings that can be formed from the strings of a PCP.\\
Steps:
\begin{enumerate}
	\item We start with two sets of sessions, one for the 
	$A$ strings of the PCP, and one for the $B$ strings.
	\item Each string is encoded in the method described above.
	\item Remove the initial oracle introduced IV from each 
	session. 
	\item After encoding one or more strings we add a special 
	nonce to the end of the strings that encodes the index's of the strings concatenated together. The nonce used 
	to encode the index in the $A$ strings must be the same nonce
	for the same index in the $B$ strings. For example, 
	$A_1A_3$ use the nonce '$13$', and $B_1B_3$ would use the same
	nonce '$13$'. In this way only encodings of the $A$ strings with the same nonce as those strings in $B$ could be unified.
	\item After encoding an index, check if the cypher block can be unified. If yes, then stop. If not, remove the nonce, as described above. Start new sessions, one for each new index. 
	For example, if you encoded $A_1$, you would then create 
	sessions for $A_1A_1$ and sessions for 
	$A_1A_2$ and $A_1A_3$. 
\end{enumerate}

Notice that any possible string formed from the initial PCP strings 
can be encoded into a cypher block. Only those blocks sharing the
same index nonce from the $A$ strings and $B$ strings can be unified.
If there is a unifier there is a solution to the PCP. 


\subsubsection{Dealing with $IV$}\label{sec_iv}
We need in several cases to remove the $IV$, either to chain 
sessions without including a new $IV$ or to ensure two 
different sessions have the same fake $IV$. More information on these methods are below. Here we describe how to replace the $IV$ added
to the block $C_1 = (p_1 \oplus IV)$. 
\begin{align*}
p_1 &= 0\\
c_1 &= f(0 \oplus IV) = f(IV)\\
p_2 &= c_1\\
c_2 &= f(c_1 \oplus c_1) = f(0)
\end{align*}
Notice that if we want to simulate something like an $IV$, but
that we know, we could replace $0$ in the above interaction 
with some nonce $k$. This will be useful when we want two 
sessions to have the same starting nonce. 


\subsubsection{Dealing with $IV$ without a $h()$:}\label{sec_iv}
We need in several cases to remove the $IV$, either to chain 
sessions without including a new $IV$ or to ensure two 
different sessions have the same fake $IV$. More information on these methods are below. Here we describe how to replace the $IV$ added
to the block $C_1 = (p_1 \oplus IV)$. 
\begin{align*}
p_1 &= 0\\
c_1 &= f(0 \oplus IV) = f(IV)\\
p_2 &= c_1\\
c_2 &= f(c_1 \oplus c_1) = f(0)
\end{align*}
Notice that if we want to simulate something like an $IV$, but
that we know, we could replace $0$ in the above interaction 
with some nonce $k$. This will be useful when we want two 
sessions to have the same starting nonce. 

\subsubsection{Encoding strings without a $h()$:}
We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
setting each character of the string as a plaintext block 
and sending each to the oracle from left to right, one at a 
time. For example,  $A_i = a_1 a_2 a_3 a_4$:
\begin{align*}
p_1 &=a_1\\
c_1 &=f(a_1 \oplus IV)\\
p_2 &=a_2\\
c_2 &=f(a_2 \oplus c_1)\\
&\ldots\\
c_4 &=f(a_4 \oplus c_3)
\end{align*}

\subsubsection{Chaining multiple strings without a $h()$:}
We also need to chain together the encodings of two or more strings. For example, if we wanted to encode $A_1A_2$. We
could just encode them in the same session but it will be
useful below to start a new session when concatenating 
a string onto the end of another string. We do this as 
follows:
\begin{itemize}
	\item Suppose we have two string $A_1 = a_{11}a_{12}$, and 
	$A_2 =a_{21}a_{22}$.
	\item Encoding the first string we get 
	$c^1_2 = f(a_{12} \oplus f(a_{11}\oplus IV))$.
	\item Start a second session and remove the $IV$:
	\begin{align*}
	c^2_1 &= f(0 \oplus IV) = f(IV)\\
	c^2_2 &= f(c^2_1 \oplus c^2_1) = f(0)\\
	c^2_3 &= f(a_{21} \oplus c^1_2 \oplus c^2_2 \oplus c^2_2) =
	f(a_{21} \oplus c^1_2)
	\end{align*}
\end{itemize} 

\subsubsection{Adding/Removing a final nonce to encode the index without a $h()$:}
After we have encoded one or more strings together we can 
add a nonce that is used to indicate the index of the encoded
strings and there order. For example, if we encode $A_1A_3$, 
we can add a nonce, '$13$' to a final cypher block. Notice
when we encode $B_1B_3$ we can add the same final nonce. This
ensures that only strings with the same index could possibly 
be unified since only these strings will have matching final 
nonces. 

nonces can then be removes by applying the same method above.
This allows us to remove a nonce, concatenate another string 
onto the encoding, add a new nonce indicating the new index, 
test for unifiability.

\subsubsection{Encoding all possible permutations without a $h()$:}
We now have all the tools needed to encode the possible 
strings that can be formed from the strings of a PCP.\\
Steps:
\begin{enumerate}
	\item We start with two sets of sessions, one for the 
	$A$ strings of the PCP, and one for the $B$ strings.
	\item Each string is encoded in the method described above.
	\item Remove the initial oracle introduced IV from each 
	session. 
	\item After encoding one or more strings we add a special 
	nonce to the end of the strings that encodes the index of the 
	index of the strings concatenated together. The nonce used 
	to encode the index in the $A$ strings must be the same nonce
	for the same index in the $B$ strings. For example, 
	$A_1A_3$ use the nonce '$13$', and $B_1B_3$ would use the same
	nonce '$13$'. In this way only encodings of the $A$ strings with the same nonce as those strings in $B$ could be unified.
	\item After encoding a an index, check if the cypher block can be unified. If yes, then stop. If not, remove the nonce, as described above. Start new sessions, one for each new index. 
	For example, if you encoded $A_1$, you would then continue this
	sessions for $A_1A_1$ and start two new sessions for 
	$A_1A_2$ and $A_1A_3$. 
\end{enumerate} 

\subsection{The Active Adversary $MOE_{\oplus}$-decision problem for bound Sessions of bound Length}
The first decision problem to consider is the $MOE_{\oplus}$
problem with a finite bound on both the number of sessions and
the sessions lengths. 
For both schedules and both $MOE$s, $CBC$ and $CFB$, the problem
reduces to the $MOE$-unification problem for $E=xor$. This problem
has been solved in the positive [Chris and Hia Paper].

\subsection{The Active Adversary $MOE_{\oplus}$-decision problem for Arbitrary Sessions of Arbitrary Length and a $h()$ function}
Let's now consider the $MOE_{\oplus}$-decision problem
for an active adversary, unbounded number of sessions, and unbounded session lengths. In addition, we assume the adversary has the ability 
to use a hash function, $h()$.
 
\begin{theorem}\label{thm:unbounded_unbounded}
The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
sessions, unbounded session lengths, immediate schedule, and CBC. 
\end{theorem}
\begin{proof}\todo{Andrew: Need to improve the proof}
	\textit{Claim 1:} These exists a unifier to two cypher blocks
	of the MOE program described in Section~\ref{sec:encoding} iff
	there is a solution to the corresponding PCP.
	\noindent
	\text{Claim Proof Sketch:}\\
	If there is a unifier it has to be between two string encoded 
	with the same index from the upper and lower parts of the PCP
	due to the unique nonces encoding the index and the position encoding.
	If there is a solution to the PCP, that solution will evidentially
	be encoded into two sessions that are unifiable. 
\end{proof}

\begin{example}
	Consider the following PCP:
	\[
	(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
	\]
	The solution for this basic PCP problem is $1,3$.
	
	We would start with two sets of sessions, one for the 
	upper strings. $ba, ~ab, ~aaa$, and one for the lower
	strings, $baa, ~ba, ~aa$. One session for each of the initial strings. 
	
	\noindent
	$A$ Sessions:
	\begin{enumerate}
		\item Session1, string ``ba'':
		\begin{align*}
		p_1 &= 0\\
		c^{A1}_1 &= f(0 \oplus IV_{1})\\
		p_2 &= r_1 \oplus h(b) \oplus h^2(a) \oplus c^{A1}_1\\
		c^{A1}_2 &= f(r_1 \oplus h(b) \oplus h^2(a) \oplus c^{A1}_1 \oplus c^{A1}_1) = f(r_1 \oplus h(b) \oplus h^2(a))
		\end{align*}
		\item Session2, string ``ab'':
		\begin{align*}
			c^{A2}_2 &=f(r_2 \oplus h(a) \oplus h^2(b))
		\end{align*}
		\item Session3, string ``aaa'':
		\begin{align*}
			c^{A3}_2 &=f(r_3 \oplus h(a) \oplus h^2(a) \oplus h^3(a))
		\end{align*}
	\end{enumerate}
	
	\noindent
	$B$ Sessions:
\begin{enumerate}
	\item Session1, string ``baa'':
	\begin{align*}
	c^{B1}_2 &= f(r_1 \oplus h(b) \oplus h^2(a) \oplus h^3(a))
	\end{align*}
	\item Session2, string ``ba'':
	\begin{align*}
	c^{B2}_2 &= f(r_2 \oplus h(b) \oplus h^2(a))
	\end{align*}
	\item Session3, string ``aa'':
	\begin{align*}
	c^{B3}_2 &= f(r_3 \oplus h(a) \oplus h^2(a))
	\end{align*}
\end{enumerate}
 
Now try if we look for unifiers of the above cypher blocks, 
$c^{A1}_2, ~c^{A2}_2, ~c^{A3}_2, ~c^{B1}_2, ~c^{B2}_2, ~c^{B3}_2$.
We don't find a unifier so we move on to test the next level of
possible strings, those with index: $11, 12, 13, 21, 22, 23, 31, 32, 33$. For these we first remove the current nonce encoding an index, 
then concatenate the two strings, and then add the new nonce for the
new index.  To save space we will just show this process for 
the index $1,3$ (the solution) for the $A$ sessions and the $B$ sessions.

SessionA, string `$A_1A_2 = ba \cdot aaa$:
\begin{align*}
p_1 &= 0\\
c^{A}_1 &= f(0 \oplus IV_{1})\\
p_2 &= r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a) \oplus c^{A}_1\\
c^{A}_2 &= f(r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a))\\
\end{align*}
SessionB, string `$B_1B_2 = baa \cdot aa$:
\begin{align*}
p_1 &= 0\\
c^{B}_1 &= f(0 \oplus IV_{2})\\
p_2 &= r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a) \oplus c^{B}_1\\
c^{B}_2 &= f(r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a))\\
\end{align*}

Now if we check for unifiers we find one for $c^{A}_2$ and 
$c^{B}_2$, which corresponds to the PCP solution $1,3$.
 
 
\end{example}



 
\subsection{The Active Adversary $MOE_{\oplus}$-decision problem for Arbitrary Sessions of Arbitrary Length, and no $h()$ function}
In this section we assume the adversary is active but doesn't have
the ability to apply the $h()$ function.
apply the $h()$ function. For this approach to work we need to make the following assumptions:
\begin{enumerate}
	\item The adversary decides when it wants to check if cypher
	blocks are unifiable.
	\begin{itemize}
		\item That is, the adversary does not have to check 
		for unifiers every time a cypher block is revived back from
		the oracle.   
	\end{itemize}
	\item The adversary can decide what blocks to try to unify.
	\begin{itemize}
		\item When checking for unifiers the adversary doesn't have to
		check all pairs of cypher blocks for unifiers but only those
		pairs he is interested in. 
	\end{itemize} 
\end{enumerate}

Based on these assumptions we can construct a different reduction from
the PCP to the $MOE_{\oplus}$-decision problem. 


\subsubsection{$MOE_{\oplus}$ decision problem for unbounded 
	sessions and unbounded session lengths}
\begin{theorem}\label{thm:unbounded_unbounded}
	The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
	sessions, unbounded session lengths, immediate schedule, and CBC. 
\end{theorem}
\begin{proof}
\end{proof}

\begin{example}
	Consider the following PCP:
	\[
	(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
	\]
	The solution for this basic PCP problem is $1,3$.
	
	We would start with two sets of sessions, one for the 
	upper strings. $ba, ~ab, ~aaa$, and one for the lower
	strings, $baa, ~ba, ~aa$. One session for each of the initial strings. 
	
	\noindent
	$A$ Sessions:
	\begin{enumerate}
		\item Session1, string ``ba'':
		\begin{align*}
		p_1 &= 0\\
		c^{A1}_1 &= f(0 \oplus IV_{1})\\
		p_2 &= b \oplus c^{A1}_1\\
		c^{A1}_2 &= f(b \oplus c^{A1}_1 \oplus c^{A1}_1)\\
		p_3 &= a\\
		c^{A1}_3 &= f(a \oplus c^{A1}_2)\\
		&\text{Add the nonce for the index, 1 in this case}\\
		c^{A1}_4 &=f(1, \oplus c^{A1}_3)
		\end{align*}
		\item Session2, string ``ab'':
		\begin{align*}
		c^{A2}_3 &= f(b \oplus c^{A2}_2)\\
		&\text{Add the nonce for the index, 2 in this case}\\
		c^{A2}_4 &=f(2, \oplus c^{A2}_3)
		\end{align*}
		\item Session3, string ``aaa'':
		\begin{align*}
		c^{A3}_4 &= f(a \oplus c^{A3}_3)\\
		&\text{Add the nonce for the index, 3 in this case}\\
		c^{A3}_5 &=f(3, \oplus c^{A3}_4)
		\end{align*}
	\end{enumerate}
	
	\noindent
	$B$ Sessions:
	\begin{enumerate}
		\item Session1, string ``baa'':
		\begin{align*}
		c^{B1}_4 &= f(a \oplus c^{B1}_3)\\
		&\text{Add the nonce for the index, 1 in this case}\\
		c^{B1}_5 &=f(1, \oplus c^{B1}_4)
		\end{align*}
		\item Session2, string ``ba'':
		\begin{align*}
		c^{B2}_3 &= f(a \oplus c^{B2}_2)\\
		&\text{Add the nonce for the index, 2 in this case}\\
		c^{B2}_4 &=f(2, \oplus c^{B2}_3)
		\end{align*}
		\item Session3, string ``aa'':
		\begin{align*}
		c^{B3}_3 &= f(a \oplus c^{B3}_2)\\
		&\text{Add the nonce for the index, 3 in this case}\\
		c^{B3}_4 &=f(3, \oplus c^{B3}_3)
		\end{align*}
	\end{enumerate}
	
	Now try if we look for unifiers of the above cypher blocks, 
	$c^{A1}_4, ~c^{A2}_4, ~c^{A3}_5, ~c^{B1}_5, ~c^{B2}_4, ~c^{B3}_4$.
	We don't find a unifier so we move on to test the next level of
	possible strings, those with index: $11, 12, 13, 21, 22, 23, 31, 32, 33$. For these we first remove the current nonce encoding an index, 
	then concatenate the two strings, and then add the new nonce for the
	new index.  To save space we will just show this process for 
	the index 1,3 (the solution) for the $A$ session.
	
	Session1, string ``ba'':
	\begin{align*}
	p_1 &= 0\\
	c^{A1}_1 &= f(0 \oplus IV_{1})\\
	p_2 &= b \oplus c^{A1}_1\\
	c^{A1}_2 &= f(b \oplus c^{A1}_1 \oplus c^{A1}_1)\\
	p_3 &= a\\
	c^{A1}_3 &= f(a \oplus c^{A1}_2)\\
	&\text{Add the nonce for the index, 1 in this case}\\
	c^{A1}_4 &=f(1, \oplus c^{A1}_3)\\
	&\text{end of encoding of string 1, ``ba''}\\
	&\text{start a new session to add string ''aaa''}\\
	p_1 &= 0\\
	c^{A1,3}_1 &= f(0 \oplus IV)\\
	p_2 &= a \oplus c^{A1}_3 \oplus c^{A1,3}_1\\
	c^{A1,3}_2 &= f(a \oplus c^{A1}_3 \oplus c^{A1,3}_1 \oplus c^{A1,3}_1 ) = \\ f(a \oplus c^{A1}_3) \\
	&\ldots \\
	c^{A1,3}_4 &= f(a \oplus c^{A1,3}_3) \\
	&\text{Add the new index 1,3}\\
	c^{A1,3}_5 &= f(13 \oplus c^{A1,3}_4) \\
	\end{align*}
	Notice that for the string in the $B$ sessions with index $1,3$ we get
	$c^{B1,3}_5 = f(13 \oplus c^{B1,3}_4)$.
	
	Now if we check for unifiers we find one for $c^{A1,3}_5$ and 
	$c^{B1,3}_5$, which corresponds to the PCP solution $1,3$.
	
	
\end{example}	

\subsection{Finite Length with Arbitrary Sessions}

\begin{lemma}\label{lemma:sim_arbitrary_length}
	Given a $MOE_{\oplus}$ program with sessions of fixed length,
	sessions of arbitrary length can be simulated provided 
	an arbitrary number of sessions can be created. 	
\end{lemma}
\begin{proof}
	Suppose there is a bound, $n$, on the length of a sessions, 
	i.e., the number of cypher blocks per session. Suppose you wanted to continue a session beyond the bound, create a $c_{n+1}$ from 
	a $c_{n}$. You need to create a new sessions, remove the 
	new $IV$ (as is done above), add $c_{n}$, and continue. 
	Provided you have an arbitrary number of sessions this can continue
	providing arbitrary length for sessions. 
\end{proof}

\begin{theorem}\label{thm:bounded_unbounded}
	The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
	sessions, bounded session lengths, immediate schedule, and CBC.	
\end{theorem}
\begin{proof}
	From Lemma~\ref{lemma:sim_arbitrary_length} 
	and Theorem~\ref{thm:unbounded_unbounded}.
\end{proof}

\subsection{Finite Sessions of Arbitrary Length}
\begin{lemma}\label{lemma:sim_arbitrary_sessions}
	Given a $MOE_{\oplus}$ program with sessions of arbitrary length
	and a bounded number of sessions,
	an unbounded number of sessions can be simulated. 	
\end{lemma}
\begin{proof}
	Suppose there is a bound, $n$, on the number of sessions. Suppose you wanted to create a new, $n+1$, session. We can add a new
	session to an existing one by doing the following: 
	remove the old cypher block, add a random nonce, and the 
	first plain text of the new session. Notice if you want to 
	continue the old session, just repeat the steps but add 
	the old cypher test as the first plain text.  
\end{proof}  


\begin{theorem}\label{thm:unbounded_bounded}
	The $MOE_{\oplus}$ decision problem is undecidable for bounded 
	sessions, unbounded session lengths, immediate schedule, and CBC.	
\end{theorem}
\begin{proof}
	From Lemma~\ref{lemma:sim_arbitrary_sessions} 
	and Theorem~\ref{thm:unbounded_unbounded}.
\end{proof}

\section{Decision Problems with an Oracle Encoding the PCP}
In this section we consider the case where the adversary is passive, 
it doesn't attempt to encode the PCP and simply applies the unification
algorithm whenever it receives a cypher block. Here the oracle will
attempt to encode the PCP strings and then pass the encodings in cypher blocks back to the oracle. We consider the same 
undecidable sub-cases as above, unbounded sessions and lengths, bounded sessions and unbounded lengths, and unbounded sessions and bounded lengths. In each of these cases the problem remains undecidable.

First we explore the string encoding methods.
\subsection{String Encoding Methods}\label{sec:encoding}
Consider an arbitrary PCP problem:
\[
(\frac{A_1}{B_1}),~(\frac{A_2}{B_2}), ~\ldots, ~(\frac{A_n}{B_n})
\]
over an alphabet $\Sigma=\{a, b\}$. 
\ignore{
	%%%OLD DEF
	We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
	setting each character of the string as a plaintext block 
	and sending each to the oracle from left to right, one at a 
	time. For example,  $A_i = a_1 a_2 a_3 a_4$:
	\begin{align*}
	p_1 &=a_1\\
	c_1 &=f(a_1 \oplus IV)\\
	p_2 &=a_2\\
	c_2 &=f(a_2 \oplus c_1)\\
	&\ldots\\
	c_4 &=f(a_4 \oplus c_3)
	\end{align*}
	%%%End of Old Def
}

\subsubsection{String Encodings with a $h()$ function}
The first method for encoding strings assumes we have a
hash function, $h()$, which can be used to enforce 
positions of characters in the strings. 
We encode a string $A_i = a_1 a_2 a_3 a_4$ by 
first using repeated applications of $h()$ to first encode
the position of that character in the string. For example,
$h^1(a_1), ~h^2(a_2), ~h^3(a_3), h^4(a_4)$.
We then combine each character in the string via $\oplus$,
$h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4)$. 


\subsubsection{String Index and Cypher Block Encoding}

For example, consider the string ``$a_1a_2a_3a_4$'' and assume
this string is contained in the ith block of the CPC problem.
Then the oracle can select an $IV$ that corresponds to a nonce, $r_i$, which will ensure only strings with the same index can be unified.
\begin{itemize}
	\item $p_1 = x_1$
	\item $c_1 = f(IV)$. 
	\item $p_2 = x_2$
	\item $c_2 = 
	f(h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4) 
	\oplus f(IV))$. 
\end{itemize} 


\subsubsection{Chaining Multiple String}
Suppose we want to now encode the new string $A_1 A_3$.
This encoding can be done as follows:
\begin{itemize}
	\item Encode the character positions using $h()$ in
	$A_1$ concatenated with $A_2$. 
	Denote these as $h(A_1A_3)$
	respectively. 
	\item Select an IV to denote the index of the string $A_1 A_3$,
	$IV = 13$.
	\item Encode the string into a cypher block and add the IV representing the index $1,3$, denotes this nonce as $r_{13}$.
	\begin{itemize}
		\item $p_2= r_{1,3} \oplus h(A_1 A_3) \oplus c_1$
		\item $c_2 = f(h(A_1 A_3) \oplus f(r_{1,3}))$
	\end{itemize} 
\end{itemize}

\subsubsection{Simulating multiple sessions in a single session}
Unlike the active adversary case, the oracle cannot create new
sessions. Therefore using a new session for each possible string 
index is not possible since we cannot ensure the creation 
of sessions when needed. However, it is possible to simulate
multiple sessions with a single session of arbitrary length.
Suppose we have single session encoding the string $A_i$ and 
now the oracle wants to create two new strings $A_iA_j$ and 
$A_iA_k$ to simulate. Suppose we are at cipher block $c_n$ 
in the sessions. That is, the adversary has sent $p_n =x_n$.
then $c_n$ is the encoding of $h(A_i A_j)$ with a new IV,
$r_{ij}$. Next, $c_{n+1}$ is the encoding of $A_iA_k$ with a
new IV, $r_{ik}$. 

\subsubsection{Encoding all Possible Permutations}
We now have all the tools needed to encode the possible 
strings that can be formed from the strings of a PCP. 
However, we need at least two sessions of arbitrary length.
The first session is used to encode the upper strings of the 
PCP and the second session the lower strings. 
Steps:
\begin{enumerate}
	\item We start with two sessions, one for the 
	$A$ strings of the PCP, and one for the $B$ strings.
	\item Each string is encoded in the method described above.
	\item The oracle adds a special 
	nonce to the end of the strings that encodes the index's of the strings concatenated together. The nonce used 
	to encode the index in the $A$ strings must be the same nonce
	for the same index in the $B$ strings. For example, 
	$A_1A_3$ use the nonce '$13$', and $B_1B_3$ would use the same
	nonce '$13$'. In this way only encodings of the $A$ strings with the same nonce as those strings in $B$ could be unified.
	\item Each cypher block sent back to the adversary will only be able to be unified with a block with the same index. 
	If no unifier is found then the index is increased and the 
	new strings are encoded, as described above, and sent back to
	the adversary.  
\end{enumerate}

Notice that any possible string formed from the initial PCP strings 
can be encoded into a cypher block. Only those blocks sharing the
same index nonce from the $A$ strings and $B$ strings can be unified.
If there is a unifier there is a solution to the PCP. 


\subsection{$MOE_{\oplus}$ decision problem for unbounded 
	sessions and unbounded session lengths}
\begin{theorem}\label{thm:unbounded_unbounded}
	The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
	sessions, unbounded session lengths, immediate schedule, and CBC. 
\end{theorem}
\begin{proof}
\end{proof}

\begin{example}
		Consider the following PCP:
		\[
		(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
		\]
		The solution for this basic PCP problem is $1,3$.
		
		We would start with two sessions, one for the 
		upper strings. $ba, ~ab, ~aaa$, and one for the lower
		strings, $baa, ~ba, ~aa$. 
		
		\noindent
		$A$ Session:
		\begin{enumerate}
			\item Session1, strings ``ba'', ``ab'', and ``aaa'':
			\begin{align*}
			p_1 &= x_1\\
			c^{A1}_1 &= f(h(b) \oplus h^2(a) \oplus r_1)\\
			p_2 &= x_2\\
			c^{A1}_2 &= f(h(a) \oplus h^2(b) \oplus r_2)\\
			p_3 &= x_3\\
			c^{A1}_3 &= f(h(a) \oplus h^2(a) \oplus h^3(a) \oplus r_3)
			\end{align*}
		\end{enumerate}
		
		\noindent
		$B$ Sessions:
		\begin{enumerate}
			\item Session1, string ``baa'', ``ba'', and ''aa'':
			\begin{align*}
			p_1 &= x_1\\
			c^{B1}_1 &= f(h(b) \oplus h^2(a) \oplus h^3(a) \oplus r_1)\\
			p_2 &= x_2\\
			c^{B1}_2 &= f(h(b) \oplus h^2(a) \oplus r_2)\\
			p_3 &= x_3\\
			c^{B1}_3 &= f(h(a) \oplus h^2(a) \oplus r_3)
			\end{align*}
		\end{enumerate}
		
		We don't find a unifier so we move on to test the next level of
		possible strings, those with index: $11, 12, 13, 21, 22, 23, 31, 32, 33$. To save space we will just show this process for 
		the index 1,3 (the solution) for the $A$ session and the 
		$B$ session.
		
		Session1, string ``ba'' combined with string ``aaa'':
		\begin{align*}
		p_1 &= n\\
		c^{A1}_n &= f(h(b) \oplus h^2(a) 
		\oplus h^3(a) \oplus h^4(a) \oplus h^5(a)
		 \oplus r_{1,3})\\
		\end{align*}
		Notice that for the string in the $B$ sessions with index $1,3$ we get
		$c^{B1}_n= f(h(b) \oplus h^2(a) 
		\oplus h^3(a) \oplus h^4(a) \oplus h^5(a)
		\oplus r_{1,3})$.
		
		Now if we check for unifiers we find one for $c^{A1}_n$ and 
		$c^{B1}_n$, which corresponds to the PCP solution $1,3$.
		
\end{example}
\subsection{The Active Adversary $MOE_{\oplus}$-decision problem for Arbitrary Sessions of Arbitrary Length, and no $h()$ function}

Note that the same string encoding $f(h(b) \oplus h^2(a) 
\oplus h^3(a) \oplus h^4(a) \oplus h^5(a)
\oplus r_{1,3})$ can be encoded without the $h()$ but still enforcing
positions in the following way: 
$f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus r_{1,3})))))$ 
this leads to the following result.

\begin{theorem}\label{thm:bounded_unbounded}
	The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
	sessions, bounded session lengths, immediate schedule, and CBC.	
\end{theorem}
\begin{proof}
\end{proof}
\vfill
\pagebreak
\subsection{Example}
Consider the following PCP:
\[
(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
\] 
Assume that the oracle has only a single session initiated by the 
adversary in which to encode the above problem. Assume also that the
$MOE$ is CBC and the schedule is immediate.  

The encoding is done as follows:
\begin{itemize}
	\item The oracle encode the strings of the PCP using a canonical ordering
	of the strings representing the index of the PCP strings. 
	For example, 
	$1, ~2, ~3, ~11, ~12, ~13, ~21, ~22, ~23, ~31, ~32, ~33, ~111, 
	\ldots$.  
	\item For each index in the above ordering the oracle encodes
	two cipher blocks, one which encodes the upper string from the 
	PCP for that index and one that encodes the lower strings.
	There are two possible encoding methods we could selected, 
	one using the $h()$ function and one without. 
	For example:
	\begin{itemize}
		\item For the index $13$ the two possible encodings for the
		upper strings would be: 
		\begin{enumerate}
			\item $f(b \oplus f(a \oplus f(a \oplus f(a \oplus
			f(a \oplus r_{13})))))$.
			\item $f(h(b) \oplus h^2(a) \oplus h^3(a) \oplus 
			h^4(a) \oplus h^5(a) \oplus r_{13})$
		\end{enumerate}
		\item For the index $13$ the two possible encodings for the
		lower strings would be: 
		\begin{enumerate}
			\item $f(b \oplus f(a \oplus f(a \oplus f(a \oplus
			f(a \oplus r_{13})))))$.
			\item $f(h(b) \oplus h^2(a) \oplus h^3(a) \oplus 
			h^4(a) \oplus h^5(a) \oplus r_{13})$
		\end{enumerate}
		\item the $r_{13}$ nonce is added to the both the upper and 
		lower encodings for the index $13$ and likewise for all other
		index. Thus only cipher blocks encoding strings with the same index can be unified. 
	\end{itemize}
	\item For each plain text sent by the adversary the oracle ignores the plain text and sends the next cipher block in the above
	canonical sequence. Thus it takes two steps to send each index
	in the sequence since there are two cipher blocks for each index, 
	one for the upper strings and one for the lower.
	\item The adversary finds a unifier for two blocks iff there
	is a solution to the PCP.
	\begin{itemize}
		\item Only upper and lower strings with the same index will 
		have the same nonce and thus be the only possible 
		unifiable cipher blocks. 
		\item All possible strings will eventually be encoded 
		with a session of arbitrary length.  
	\end{itemize}
\end{itemize}

\section{Pair Encodings by the Oracle}

In this section we look at another possible encoding, where 
the oracle sends multiple cipher blocks back to the
adversary each turn. The encoding is done as follows:
\begin{itemize}
	\item The $f$-encoding of a string $s = a_1 \cdot a_2 \cdot ~\ldots ~\cdot a_n$, denoted as $f(\bigoplus s)$, is 
	$f(a_1 \oplus f(a_2 \oplus \ldots f(a_n \oplus C_j) \ldots ))$, where $C_j$ is a cipher block containing the $f(\bigoplus s')$ 
	encoding of another string $s'$ or a nonce.
	\item Each turn the oracle encodes and return two cipher blocks. $A_i$ and $B_i$, where $A_i$ is a cipher block $f$-encoding of upper strings of the PCP, and $B_i$ the $f$-encoding of lower strings.
	$C_0 = [A_0,B_0]$, where $A_0$ is the $f$-encoding of a 
	upper string in the PCP and $B_0$ the corresponding lower string.
	The only difference for these initial encodings is the inclusion of a random nonce, $r$, instead of a prior block. More details:
	\begin{itemize}
		\item $A_i =f(a_1 \oplus f(a_2 \oplus \ldots f(a_n \oplus C_{i-1, 1}) \ldots )) $
		\item $B_i =f(b_1 \oplus f(b_2 \oplus \ldots f(b_m \oplus C_{i-1, 2}) \ldots )) $
		\item For $A_0$, $C_{i-1, 1}=r$, where $r$ is a random nonce.
		\item For $B_0$, $C_{i-1, 2}=r$, where $r$ is a random nonce.
	\end{itemize}  
	\item For each pair of cipher block, $A_i$ and $B_i$, we
	use $C_i$ to represent the pair. We distinguish the cipher blocks of the pair by a subscript. For example, if $C_i = A_i, B_i$, then 
	$C_{i,1} = A_i$ and $C_{i,2} = B_i$.
	 
\end{itemize}

The interaction works as follows:
\begin{enumerate}
	\item The adversary sends $P_i$.
	\item The oracle ignores $P_i$ and sends back $C_i$. 
	\item The adversary attempts to unify $C_{i, 1}$ with 
	$C_{i,2}$. The adversary is successful and the interaction 
	stops if a unifier is found.
\end{enumerate}

\begin{theorem}
		The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
		sessions, bounded session lengths, immediate schedule, and CBC.
\end{theorem}
\begin{proof}
	\textbf{Sketch:}\\
	Notice that for any string produced by the combination
	of strings from a PCP, there will be a cipher block $C_i$ that
	is the $f$-encoding of that string. Furthermore, 
	$C_{i,1}$ will encode the upper strings and $C_{i,2}$ will
	encode the lower strings. 
	
	Then, there exists a unifier of $C_{i,1} =^{?} C_{i,2}$ iff
	the encoded strings are a solution to the PCP.  
\end{proof}

\begin{example}
Consider the following PCP:
\[
(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
\] 
A solution to this problem is $1,3$. Notice that we get that 
encoded in the following cipher block.

The first possible ``initial blocks'':
\begin{align*}
C^1_0 &= f(b \oplus f(a \oplus r_1)), ~f(b \oplus f(a \oplus f(a \oplus r_1)))\\
C^2_0 &= f(a \oplus f(b \oplus r_2)), ~f(b \oplus f(a \oplus r_2))\\
C^3_0 &= f(a \oplus f(a \oplus f(a \oplus r_3))), ~f(a \oplus f(a \oplus r_3))\\
\end{align*}

Some of the possible blocks encoding two strings:
 
\end{example}
\begin{align*}
C^{1,3}_i &= f(a \oplus f(a \oplus f(a, C^3_{0, 1}))), ~f(a \oplus f(a \oplus C^3_{0, 2})), \text{ Encoding the string index 3,1}\\
C^{2,3}_j &= f(a \oplus f(a \oplus f(a \oplus C^2_{0, 1}))), ~f(a \oplus f(a \oplus C^2_{0, 2})), \text{ Encoding the string index 3,2}\\
C^{3,1}_k &= f(b \oplus f(a \oplus C^3_{0, 1}))), ~f(b \oplus f(a \oplus f(a \oplus C^3_{0, 2}))), \text{ Encoding the string index 1,3}\\
\end{align*}

Notice that there is a solution, $1,3$, since 
$C^{3,1}_{k, 1} = f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus r_3))))))$
 and 
$C^{3,1}_{k, 2} = f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus r_3)))$ 

}

\section{Decision Problems with 
Bounded Session Lengths and Unbounded Number of Sessions}

In this section we investigate the case where the session length
is bounded but the the number of sessions is unbounded. In this
case it's still possible to encode the PCP problem into the 
unbounded number of sessions. Here again we have two 
versions of the problem based on modeling the MOE 
program by a deterministic or a non-deterministic function.
We start by examining the non-deterministic case.

\subsection{Non-deterministic Decision Problems with 
	Bounded Session Lengths}

First, we can use the same non-deterministic function 
definition we used in Definition~\ref{non-det-func}.
We then need to show how to encode that function 
into a MOE program. 

\subsubsection{Encoding Non-deterministic Function into a Bounded Session Length MOE program}\label{sec:non-det-bounded-sessions}
We can now encode the non-deterministic function 
definition into a MOE program between an 
adversary and an oracle/encryption program. 

\begin{definition}\label{bounded-non-det-encoding}
The Adversary's actions are divided into two categories:
\begin{enumerate}
	\item Starting a new session.
	We have two subcategories here:
	\begin{enumerate}
		\item The initial session: The adversary sends a 
		$-1$ and the oracle returns the first cipher block,
		$C_0 = [r,r]$ where $r$ is a new random nonce. 
		\item New, $i+1$ session after the prior, ith, session ends: 
		The adversary sends a pair, $[j, [C_{i,1}, C_{i,2}]]$. The oracle sends back $E_{i_j}$. 
	\end{enumerate}
	\item Continuing the current sessions.
	The adversary continues as in the unbounded session 
	cases. Each ith round the adversary sends an index $j$ and
	the oracle returns $E_{i_J}$.
\end{enumerate}
\end{definition}

\begin{lemma}\label{lemma:bounded_pcp_to_moe}
	Given a PCP problem the corresponding
	bounded session $PCP_{MOE}$ program of Definition~\ref{bounded-non-det-encoding}
	produces a $\mathcal{P}$-unifiable pair of cipher blocks
	iff there is a solution the given PCP. 
\end{lemma}
\begin{proof}
	Follows from the encoding given in Definition~\ref{bounded-non-det-encoding}
\end{proof}

\begin{theorem}
	Assume $M$ is an arbitrary $MOE_{\oplus}$. The problem
	of determining if $M$, executing with 
	a unbounded number of sessions and bounded session
	lengths, ever produces two  $\mathcal{P}$-unifiable cipher blocks is undecidable. 
\end{theorem}
\begin{proof}
	Directly Lemma~\ref{lemma:bounded_pcp_to_moe}, this would
	imply that we could then solve the PCP, a contradiction.   
\end{proof}

\subsection{Deterministic Decision Problems with 
	Bounded Session Lengths}
Again we can reuse the same deterministic function 
from Definition~\ref{det-func}. We then need to 
encode this function into a MOE program. 

\subsubsection{Encoding Deterministic Function into a Bounded Session Length MOE program}\label{sec:det-bounded-sessions}
We can now encode the non-deterministic function 
definition into a MOE program between an 
adversary and an oracle/encryption program. 

\begin{definition}\label{bounded-det-encoding}

Like the non-deterministic case the adversary's actions are divided into two categories:
\begin{enumerate}
	\item Starting a new session.
	We have two subcategories here:
	\begin{enumerate}
		\item The initial session: The adversary sends a 
		$-1$ and the oracle returns the first cipher block,
		$C_0 = [r,r]$ where $r$ is a new random nonce. 
		\item New, $i+1$ session after the prior, ith, session ends: 
		The adversary sends a list of the last set of cipher blocks from $O_i$, $[C_1, C_2, \ldots, C_m]$. The oracle sends back $O_{i+1}$. 
	\end{enumerate}
	\item Continuing the current sessions.
	The adversary continues as in the unbounded session 
	cases. Each ith round the adversary sends a step $j$ and
	the oracle returns $O_{i}$.
\end{enumerate}
\end{definition}

\begin{lemma}\label{lemma:det-bounded_pcp_to_moe}
	Given a PCP problem the corresponding
	bounded session $PCP_{MOE}$ program of Definition~\ref{bounded-det-encoding}
	produces a $\mathcal{P}$-unifiable pair of cipher blocks
	iff there is a solution the given PCP. 
\end{lemma}
\begin{proof}
	Follows from the encoding given in Definition~\ref{bounded-det-encoding}
\end{proof}

\begin{theorem}
	Assume $M$ is an arbitrary $MOE_{\oplus}$. The problem
	of determining if $M$, executing with 
	a unbounded number of sessions and bounded session
	lengths, ever produces two  $\mathcal{P}$-unifiable cipher blocks is undecidable. 
\end{theorem}
\begin{proof}
	Directly Lemma~\ref{lemma:det-bounded_pcp_to_moe}, this would
	imply that we could then solve the PCP, a contradiction.   
\end{proof}


\section{The Invertibility Problem}
A natural requirement of any cryptographic algorithm is that given a
cipher block encoding of a plain text message and the ability to decrypt, the original plain text can be obtained. That is, one can decrypt a cipher block to obtain the original plain text given you 
have the key. Thus in the automatic synthesis of cryptosystem we 
need to be able to check that this property holds. For cryptosystems
modeled symbolically as MOEs this leads to the invertibility problem.

Let $\phi = \nu \tilde{n}.\sigma$, be a frame where 
$\sigma$ is a ground substitution, s.t., 
$\sigma = \{x_0 \mapsto C_0, x_1 \mapsto C_1, \ldots, 
	x_n \mapsto C_n\}$. Thus, $\sigma$ represents the ground
cipher blocks, $C_i$, produced by the $MOE$ at step 
$i$. Let $P = \{M_0, M_1, \ldots, M_n\}$ be the set of
ground terms representing the plaintext messages where
$M_i$ is a subterm of $C_i$.  The \emph{invertibility} problem
is given by the relation $\phi \vdash_{E^{-1}} M$, s.t.
$M \in P$. This relation is axiomatized by the following rules.

\vspace*{0.1in}
\begin{tabular}{lcc}
	(a) & $\qquad$ & $\vcenter{
		\infer[\qquad \mathrm{if} ~ x \in Dom(\sigma), ~x\sigma=M_i ]{ \phi \vdash_{E^{-1}} M_i }
		{  }
	}
	$\\[+30pt]
	(b) & $\qquad$ & $\vcenter{
		\infer[\qquad s \in \tilde{n} ]{ \phi \vdash_{E^{-1}} s }
		{  }
	}
	$\\[+30pt]
	(c) & & $\vcenter{
		\infer{\phi \vdash_{E^{-1}} M_1, \ldots \phi \vdash_{E^{-1}} M_l}
		{\phi \vdash_{E^{-1}} f(M_1, ~M_2, \ldots, ~M_l)}
	}
	$\\[+30pt]
	(d) & $\qquad$ & $\vcenter{
		\infer[\qquad s.t. ~g \neq f ]{ \phi \vdash_{E^{-1}} g(M_1, ~M_2, \ldots, ~M_l) }
		{ \phi \vdash_{E^{-1}} M_1, \ldots \phi \vdash_{E^{-1}} M_l }
	}
	$\\[+30pt]
	(e) & $\qquad$ & $\vcenter{
		\infer[\qquad M_i =_{E} M_j ]{ \phi \vdash_{E^{-1}} M_j }
		{ \phi \vdash_{E^{-1}} M_i }
	}
	$
	
\end{tabular} 


\vspace*{0.1in}
Notice that if we introduce a new symbol, $f^{-1}$, where $f$ is the symbolic encryption function, i.e., $f = enc(\_, K)$, for some key $K$, and let $f^{-1}$ model decryption, 
$f^{-1} = dec(\_, K)$, s.t. $f^{-1}(f(M)) = M$. 
Then by augmenting $E$, s.t., $E^{-1} = E \cup  \{f^{-1}(f(x)) = x\}$, rule $(c)$ is subsumed by 
rule $(e)$. In this case the set of rules 
axiomatizing the invertibility problem are exactly those
axiomatizing the deduction problem~\cite{DBLP:journals/tcs/AbadiC06, Cortier2010}.
We then obtain the following result.

\begin{lemma}\label{lem:invert_equiv_deduc}
(\cite{DBLP:journals/tcs/AbadiC06}), The invertibility 
problem is equivalent to the intruder deduction problem. 
\end{lemma}

Since the intruder duduction problem is undecidable in 
general, so is the invertibility problem. 

\begin{corol}\label{cor:invert_undec}
The invertibility problem is undecidable in general.
\end{corol}

However, like deduction the invertibility problem is 
decidable for some cases. 

\subsection{Invertibility as a Unification problem}
Following the direction of the deduction problem we 
can characterize the invertibility problem as a type
of unification problem. 

\begin{definition}\label{def:recipe}
Let $\phi = \nu \tilde{n}.\sigma$ be a frame, and $t$ a ground term. 
We denote $\phi \vdash_E t$ if there exists a term $s$ such that $s\sigma =_{E} t$ and $fn(s) \cap \tilde{n} = \emptyset$. The term $s$ is called a \emph{recipe} of $t$ in $\phi$ modulo $E$.
\end{definition}

\begin{lemma}\label{lem:deduc_recipe}
(\cite{DBLP:journals/tcs/AbadiC06})
Let $M$ be a ground term and  $\phi = \nu \tilde{n}.\sigma$ a frame. Then $\phi \vdash_E M$ iff $\exists$ a recipe of
$M$ in $\phi$ modulo $E$. 
\end{lemma} 

Therefore, by the equivalence we get. 

\begin{corol}
Let $M$ be a ground term and  $\phi = \nu \tilde{n}.\sigma$ a frame. Then $\phi \vdash_E^{-1} M$ iff $\exists$ a recipe of $M$ in $\phi$ modulo $E^{-1}$. 
\end{corol}

We now look at some the specific xor based cases explored 
in the decision problem section. 

\subsection{Invertibility in $MOE_{\oplus}$ Frames}

\todo{Andrew: hopefully add the new algorithm(s) here }

\section{Conclusions}


\appendix

\section{Alternative Bounded Session length Encoding}
For all dominoes $\big( A_i , \; B_i \big)$ except the start domino and the end domino, we create
\[
\begin{array}{cl}
x_1 & \qquad y_1 \, := \, r \; \oplus \; f( x_1 ) \\[+10pt]
x_2 & \qquad y_2 \, := F(A_i \bigoplus  x_2 \; \oplus \;   f(x_1))\; ~ \oplus ~ \; f( y_1 ) \\[+10pt]
x_3 & \qquad y_3 \, := \,  F(B_i \bigoplus  x_3 \; \oplus \; f(f(x_1))) ~ \oplus ~ \; f(f( y_1 )) \\[+10pt]
\end{array}
\]

For the end domino we create
\[
\begin{array}{cl}
x_1 & \qquad y_1 \, := \, r \; \oplus \; f( x_1 ) \\[+10pt]
x_2 & \qquad y_2 \, := \, F(A_i \bigoplus x_2) \; \oplus \;   f( y_1 ) \\[+10pt]
x_3 & \qquad y_3 \, := \,  F(B_i \bigoplus x_3) \; \oplus \; f(f( y_1 )) \\[+10pt]
\end{array}
\]


For the start domino $\big( A_0 , \; B_0 \big)$, we create
\[
\begin{array}{cl}
x_1 & \qquad y_1 \, := \, r \; \oplus \; f( x_1 ) \\[+10pt]
x_2 & \qquad y_2 \, := \, F(A_0 \bigoplus( x_2  \; \oplus \;   f(x_1) \big)\\[+10pt]
x_3 & \qquad y_3 \, := \,  F(B_0 \bigoplus( x_3  \; \oplus \; f(f(x_1)) \big)\\[+10pt]
\end{array}
\]

The output is $\big[ f(r), \, y_1, \, y_2, \, y_3 \big]$ in all cases.

%\ifthenelse {\value{page} > 1} {\thispagestyle{plain}} %{\thispagestyle{empty}}

\begin{theorem}
	Assume $M$ is an arbitrary $MOE_{\oplus}$. The problem
	of determining if $M$, executing with 
	a unbounded number of sessions and bounded session
	lengths, ever produces two  $\mathcal{P}$-unifiable cipher blocks is undecidable. 
\end{theorem}
\begin{proof}
	
\end{proof}

\bibliographystyle{plain}
\bibliography{MOE_bib}
\end{document}
