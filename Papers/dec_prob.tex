%\documentclass{llncs}
\documentclass[11pt,twoside,a4paper]{article}
\usepackage{amssymb, amsthm}
\usepackage{proof}
\usepackage{url}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{latexsym, graphics, graphicx}
\usepackage{color}
\usepackage{epsfig, amssymb}
\usepackage{yfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{float}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{marginnote}
\usepackage{mathtools}
\usepackage{todonotes}


\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{corol}{Corollary}
\newtheorem{proprt}{Property}
\newtheorem{lemma}{Lemma}
\newtheorem{restn}{Restriction}
\newtheorem{modif}{Modification}
\newtheorem{assumption}{Assumption}

\newcommand{\pa}{{\bf Pair}}
\newcommand{\enc}{{\bf Enc}}
\newcommand{\eq}{\mathcal{EQ}}
\newcommand{\bphi}{\ovr{\phi}}
\newcommand{\bh}{\ovr{h}}
\newcommand{\tdh}{\tilde{h}}
\newcommand{\ignore}[1]{}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}

%\newcommand{\ISFULL}

\ifdefined\ISFULL
\newcommand{\FULL}[1]{#1}
\newcommand{\SHORT}[1]{}
\else
\newcommand{\FULL}[1]{}
\newcommand{\SHORT}[1]{#1}
\fi



\title{ $MOE$ Decision Problems}


\begin{document}
\tableofcontents
\maketitle
\begin{abstract}
The $MOE$ decision problem. 

\end{abstract}


\pagebreak


\section{Definitions}

\begin{definition}
	$MOE$-terms: Given a first-order signature $\Sigma$, a countable set of (free) constants (names) $N$, such that $\Sigma \cap N =\emptyset$, and a (countable) set of variables $X$, the set of $MOE$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$. 
\end{definition}



\begin{definition}
	$MOE$-Program: Is an interaction between the 
	the adversary and the oracle consisting of the following actions
	and orders. Let $c$ be a name representing a session identifier.
	\begin{enumerate}
		\item $start(c)$. The start of a session $c$, sent from the
		adversary to oracle.
		\item $stop(c)$. The end of session $c$.
		\item $block(c, x)$. A new block in session $c$ sent from
		the adversary to the oracle. This is to be encrypted by the 
		oracle. This variable, $x$, represents possible messages, via
		instantiation, that the adversary could send during a program
		run. 
		\item $send(c, m)$. The oracle send a $MOE$-term, $m$, back
		to the adversary. The variables of $m$ must have been 
		previously contained in a received $block(c, x)$ message
		that occurred before the $send(c, m)$ message.
	\end{enumerate} 
\end{definition}
This ordering in the last item will be important to the decision 
problems. We can more compactly represent the sequence of messages
in a $MOE$-program as a frame. 

\begin{definition}
	$MOE_{\oplus}$-terms: Given a first-order signature $\Sigma=\{
	\oplus, 0, f, h\}$, a countable set of (free) constants (names) $N$, such that $\Sigma \cap N =\emptyset$, and a (countable) set of variables $X$, the set of $MOE_{\oplus}$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$. 
\end{definition}

\begin{definition}
		$MOE$-frame:  $\phi = \nu \tilde{n}.\sigma$, where
		$\tilde{n}$ is a set of names representing non-free variables such as random nonces. $\sigma$ is a substitution
		such that $Dom(\sigma) = \{ y_1, y_2, \ldots, y_n\}$,
		$Dom(\sigma) \cap \tilde{n} = \emptyset$, and
		$Ran(\sigma)$ are $MOE$-terms.  
\end{definition}

A $MOE$-frame models a trace of a $MOE$ program in the following way:
if the $i$th action of the challenger in the trace of a given session $c$ is 
$block(c, t)$ or $send(c, t)$, where $t$ is a $MOE$-term, 
then there is a variable $y_i \in Dom(\sigma)$ and 
$y_i \sigma \mapsto t$. Random variables such as the IV are 
modeled as names and placed in $\tilde{n}$.

The terms of the frame are further restricted depending on the mode of encryption being modeled and the schedule used by the oracle to
return cipher blocks to the adversary. These restrictions have
the following impact on the $MOE$-frames:
\begin{itemize}
	\item $MOE$: The mode of encryption dictates how the oracle 
	constructs cypher blocks. For example, in a Cipher Block Chaining,
	$CBC$, $MOE$ the ith block of cipher text, $C_i$, is modeled by
	the $y_i \mapsto f(C_{i-1} \oplus x_i)$, where $\oplus$ is
	the xor function.
	\item Schedule: The oracle can either return the 
	cipher blocks immediately or at the end of the session.  
\end{itemize}

The adversary has the ability to execute multiple simultaneous session with the oracle. In this case the initial name, the IV, will be fresh for each session. Each session can then be modeled by it's own frame. 


%\begin{definition}
%	Let 
%\end{definition}


We model a potential attack via a decision problem involving unification. First we need a new definition of unification which includes the 
constraint on term orders imposed by the $MOE$-program. This 
ordering can be enforeced using a relation $\prec_{\mathcal{P}}$, defined 
as follows. 

\begin{definition}
	Let $\mathcal{P}$ be a $MOE$-program and $\phi = \nu \tilde{n}.\sigma$ the corresponding frame. We define a relation, 
	$\prec_{\mathcal{P}}$, by:
	\begin{itemize}
		\item $t \prec_{\mathcal{P}} x$,
		$y_i \mapsto x, ~y_j \mapsto t ~ \in \sigma$, and
		$ i < j$.
		\item $x_i \prec_{\mathcal{P}} x_j$ iff 
		 $y_i \mapsto x_i, ~y_j \mapsto x_j ~ \in \sigma$, and
		 $ i < j$.
		 \item If $\bar{t} \prec_{\mathcal{P}} x$, then 
		 $f(\bar{t}) \prec_{\mathcal{P}} x$, where $f \in \Sigma$.
		 \item $t \not \prec_{\mathcal{P}} x$ iff $t \prec_{\mathcal{P}} x$ does not hold.
	\end{itemize}
\end{definition}

We can now define the $MOE$ unification problem.

\begin{definition}
	Let $\mathcal{P}$ be a $MOE$-program and $\phi = \nu \tilde{n}.\sigma$ the corresponding frame. Let $t_1$ and $t_2$
	be two $MOE$-terms appearing in $\mathcal{P}$. $t_1$ and $t_2$
	are $\mathcal{P}$-unifiable iff there exists some substitution
	$\delta$ s.t.
	\begin{itemize}
		\item $\forall x \in Dom(\delta), ~x\delta \prec_{\mathcal{P}} x$.
		\item $t_1 \delta =_E t_2\delta$.
	\end{itemize}
\end{definition}

We are interested in the problem of deciding if the adversary is able to $\mathcal{P}$-unify two cipher blocks. We can define several instances of the problem based on the combination of the following factors:
\begin{itemize}
	\item The equational Theory $E$.
	\item The $MOE$.
	\item The Schedule.
	\item Bounds on the session length and number of sessions.  
\end{itemize}

Here we will consider $\Sigma ={\oplus, 0, f, IV}$, where $\oplus$ is xor and $f=enc(K,\_)$, $IV$ is an initialization vector.
Several examples of $MOE$ using this signature are: 
\begin{itemize}
	\item Cipher Block Chaining $(CBC):$ The ith plain text is modeled via a term consisting of a single variable $x_i$. The initial cipher block, the IV, is modeled by a name, $r$. The ith block of cipher text, $C_i$, is modeled by a
	term $f(C_{i-1} \oplus x_i)$.
	\item Cipher Feedback $(CFB):$ The ith plain text is modeled via a term consisting of a single variable $x_i$. The initial cipher block is modeled by a name, $r$. The ith block of cipher text, $C_i$, is modeled by a
	term $f(C_{i-1}) \oplus x_i$.  
	\item Propagating Cipher Block Chaining ($PCBC$): 
	$C_1 = f(P_1 \oplus IV)$, $C_i = f(P_i \oplus P_{i-1} \oplus C_{i-1})$.
\end{itemize}

\section{Non-deterministic Decision Problem}

In this section we prove that the non-deterministic version 
of the decision problem is undecidable.

\begin{definition}
If $A_i$ be a string such that $A_i = a_0 a_1\ldots a_m$ and 
$C_j$ some cipher block, let $F(A_i \bigoplus C_j) =
f(a_0 \oplus f(a_1 \oplus \ldots f(a_m \oplus C_j) \ldots ))$
\end{definition}

\begin{example}
Assume you have a string A = "abd" and assume $C$ is some cipher
block. Then, 
\[F(A \bigoplus C) = 
f(a \oplus f(b \oplus f(d \oplus C)))
\]
\end{example}



\begin{definition}\label{non-det-func}
Let $PCP = ~(\frac{A_0}{B_0}), ~(\frac{A_1}{B_1}), ~\ldots, ~(\frac{A_n}{B_n})$. 	
	
Let $C_i$ be the ith output of the cryptosystem. 
For $i > 0$ let $C_i = E_{i_0}$ or, $E_{i_2}$, or $\ldots$,
$E_{i_n}$ where 
\begin{align*}
	E_{i_j} &= [f(r_i \oplus C_{i, 1}), f(r_i \oplus C_{i,2}) ] \\
	C_{i,1} &= F(A_j \bigoplus C_{i-1, 1})	\\
	C_{i,2} &= F(B_j \bigoplus C_{i-1, 2}) 
\end{align*}
where $r_i$ is a new random nonce.
$C_0 = [r,r]$ for a nonce $r$
\end{definition}

Notice that Definition~\ref{non-det-func} defines a 
particle $MOE_{\oplus}$ and thus we can consider the problem 
of finding an algorithm that solves the decision problem for
this $MOE$. That is, an algorithm that will determine if 
the $MOE$ will ever produce two $\mathcal{P}$-unifiable
cipher blocks.

Based on the the non-deterministic system of 
Definition~\ref{non-det-func} we can define the following
$MOE_{\oplus}$ program which produces an unsafe pair, 
two $\mathcal{P}$-unifiable cipherblocks, iff the adversary
finds a solution to the PCP.

\begin{definition}
Denote the following $MOE$ program as $PCP_{MOE}$.
The program works as follows:
\begin{itemize}
	\item The adversary non-deterministically picks a possible
	solution to the PCP, $i_0, i_1, i_2, \ldots, i_k$.
	\item Each turn the adversary sends an index in the solution, 
	starting with $i_k$ and proceeding each turn until $i_0$ 
	is reached. 
	\item The oracle encodes a pair of cipher blocks according 
	to Definition~\ref{non-det-func} and returns the pair,
	$E_j$, to the adversary.
	\item The adversary attempts to $\mathcal{P}$-unify 
	all of the current cipher blocks it knows.
	\item The program stops if the adversary finds an unsafe
	pair or it sends a stop session command.
\end{itemize}
\end{definition}

\begin{lemma}\label{lemma:pcp_to_moe}
Given a PCP problem the corresponding $PCP_{MOE}$ program 
produces a $\mathcal{P}$-unifiable pair of cipher blocks
iff there is a solution the given PCP. 
\end{lemma}
\begin{proof}
Follows from the encoding given in Definition~\ref{non-det-func}
\end{proof}



\begin{theorem}
	Assume $M$ is an arbitrary $MOE_{\oplus}$. The problem
	of determining if $M$, executing with 
	an unbounded number of sessions and unbounded session
	lengths, ever produces two  $\mathcal{P}$-unifiable cipher blocks is undecidable. 
\end{theorem}
\begin{proof}
	Assume there was such an algorithm. Then one could apply that
	algorithm to the $MOE_{\oplus}$ defined in
	Definition~\ref{non-det-func}. However, 
	from Lemma~\ref{lemma:pcp_to_moe}, this would
	imply that we could then solve the PCP, a contradiction.   
\end{proof}

\begin{example}
	Consider the following PCP:
	\[
	(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
	\] 
	A solution to this problem is $1,3$. 
	
	Let's trace a run of the $PCP_{MOE}$ program where the 
	adversary guesses the solution $1,3$.
	\begin{enumerate}
		\item In the first step the adversary sends $3$ to the
		oracle and receives the following cipher block in return.
		$C_1 = E_{1_3}$ where
		\begin{align*}
		E_{1_3} &= [f(r_1 \oplus C_{1, 1}), f(r_1 \oplus C_{1,2}) ] \\
		C_{1,1} &= F(A_3 \bigoplus C_{0, 1}) = 
		(f(a \oplus f(a \oplus f(a \oplus IV))))	\\
		C_{1,2} &= F(B_3 \bigoplus C_{0, 2}) =
		f(a \oplus f(a \oplus IV))
		\end{align*}
		\item At the second step the adversary send a $1$ to the
		oracle and receives the following in return.
		$C_2 = E_{2_1}$ where
		\begin{align*}
		E_{2_1} &= [f(r_2 \oplus C_{1, 1}), f(r_2, C_{1,2}) ] \\
		C_{2,1} &= F(A_1 \bigoplus C_{1, 1}) = 
		f(b \oplus f(a \oplus C_{1,1}))	\\
		C_{2,2} &= F(B_1 \bigoplus C_{1, 2}) =
		f(b \oplus f(a \oplus f(a \oplus C_{1,2})))
		\end{align*}
	\end{enumerate}
	Notice that now after step 2 the adversary has two 
	cipher blocks, $C_{2,1}$ and $C_{2,2}$, which are
	$\mathcal{P}$-unifiable.
	
\begin{align*}
C_{2,1} &= f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus IV))))) \\
C_{2,2} &= f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus IV)))))
\end{align*}

\end{example}


\section{Deterministic Decision Problem}
\todo{Andrew: Could do this by using multiple sessions or
	having the oracle send back more than 2 blocks. 
	I'm not sure what's the best approach.
	What do you think?}
In this section we create a deterministic version of the 
above non-deterministic program by testing not a single 
non-deterministic selected solution but rather all possible
solutions. 

\begin{definition}\label{det-func}\todo{Possible deterministic function def}
	
	Let $PCP = ~(\frac{A_0}{B_0}), ~(\frac{A_1}{B_1}), ~\ldots, ~(\frac{A_n}{B_n})$. 	
	
	Let $O_i$ be the ith output of the cryptosystem. 
	For $i > 0$ let $O_i = [E_{i_{0,0}}$, $E_{i_{0,1}}$, $\ldots$,
	$E_{i_{n,m}}]$ where $m = |O_{i-1}|$ and for 
	$0 \leq j \leq n$ and $0 \leq l \leq m$
	\begin{align*}
	E_{i_{j,k}} &= [f(r_p \oplus C_{i, 1}), f(r_p, C_{i,2}) ] \\
	C_{i_{j,k},1} &= F(A_j \bigoplus C_{i-1_{k}, 1})	\\
	C_{i_{j,k},2} &= F(B_j \bigoplus C_{i-1_{k}, 2}) 
	\end{align*}
	where $r_p$ is a new random nonce.
	$C_0 = [r,r]$ for a nonce $r$
\end{definition}

\subsection{Option One: send back all the blocks in a single session} 
The program works as follows:
\begin{itemize}
	\item For each step $i$, $0 \leq i \leq M$, the adversary
	sends $i$.
	\item The oracle encodes all combinations of blocks
	of length, $i$, according to Definition~\ref{det-func}.
	The oracle sends the list of cipher blocks back to
	the adversary.
	\item The adversary attempts to $\mathcal{P}$-unify
	the cipher blocks it knows.
	\item The session stops if an unsafe pair is found or 
	the adversary sends the stop command. 
\end{itemize}

\begin{theorem}
	The $MOE_{\oplus}$ deterministic decision problem is undecidable for unbounded session lengths, immediate schedule, and CBC.
\end{theorem}
\begin{proof}
	Notice that if there is a finite sequence giving a solution
	to the PCP at some finite number of steps that sequence will
	be produced and the adversary will find an unsafe pair.  
\end{proof}

\subsection{Option Two: Create a new session for each possible
	encoding}

The program works as follows:
\begin{itemize}
	\item Start with a single session with $C_0 = [r,r]$
	\item For each step $i > 0$, the adversary creates
	a new session for each of the possible strings of length 
	$i$. In each session it sends the previous cipher block, $C_k$, and a index $j$.
	\item The oracle encodes the blocks, $F(A_i \bigoplus C_{k, 1})$ and $F(B_i \bigoplus C_{K, 2})$ and sends them back
	to the adversary.
	\item The adversary attempts to $\mathcal{P}$-unify 
	the blocks it knows. 
	\item The program ends if an unsafe pair is found or 
	the stop command is sent by the adversary.  
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 				Old part of the paper                        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ignore{
\section{Decision Problems with an Adversary Encoding the PCP}
In this section we assume that the adversary is active and the 
oracle is passive. That is, the adversary attempts to encode the 
PCP problem strings and find unifiers. The oracle only applies the 
$f()$ function and returns cypher blocks to the adversary. 

First we explore possible string encoding methods, depending on
the existence of a hash functions $h()$, which the adversary 
could use to encode the PCP.

\subsection{String Encoding Methods}\label{sec:encoding}
Consider an arbitrary PCP problem:
\[
(\frac{A_1}{B_1}),~(\frac{A_2}{B_2}), ~\ldots, ~(\frac{A_n}{B_n})
\]
over an alphabet $\Sigma=\{a, b\}$. 
\ignore{
	%%%OLD DEF
	We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
	setting each character of the string as a plaintext block 
	and sending each to the oracle from left to right, one at a 
	time. For example,  $A_i = a_1 a_2 a_3 a_4$:
	\begin{align*}
	p_1 &=a_1\\
	c_1 &=f(a_1 \oplus IV)\\
	p_2 &=a_2\\
	c_2 &=f(a_2 \oplus c_1)\\
	&\ldots\\
	c_4 &=f(a_4 \oplus c_3)
	\end{align*}
	%%%End of Old Def
}

\subsubsection{String Encodings with a $h()$ function}
The first method for encoding strings assumes we have a
hash function, $h()$, which can be used to enforce 
positions of characters in the strings. 
We encode a string $A_i = a_1 a_2 a_3 a_4$ by 
first using repeated applications of $h()$ to first encode
the position of that character in the string. For example,
$h^1(a_1), ~h^2(a_2), ~h^3(a_3), h^4(a_4)$.
We then combine each character in the string via $\oplus$,
$h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4)$. 


\subsubsection{String Index and Cypher Block Encoding}

For example, consider the string ``$a_1a_2a_3a_4$'' and assume
this string is contained in the ith block of the CPC problem.
We then introduce a new nonce $r_i$ which will be added to ensure
only strings with the same index can be unified. 
The encoding is done as follows:
\begin{itemize}
	\item $p_1 = 0$
	\item $c_1 = f(0 \oplus IV) = f(IV)$. 
	Note, that this cypher block is 
	not unifiable with any other due to the unique IV.
	\item $p_2 = r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4) \oplus c_1$
	\item $c_2 = f(r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4) \oplus c_1 \oplus c_1) = 
	f(r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4))$. 
\end{itemize} 


\subsubsection{Chaining Multiple String}
Suppose we want to now encode the new string $A_1 A_3$.
This encoding can be done as follows:
\begin{itemize}
	\item Encode the character positions using $h()$ in
	$A_1$ concatenated with $A_2$. 
	Denote these as $h(A_1A_3)$
	respectively. 
	\item Create a sessions, and remove the initial IV.
	\item Encode the string into a cypher block and add 
	a new nonce the represents the index $1,3$, denotes this
	nonce as $r_{13}$.
	\begin{itemize}
		\item $p_2= r_{1,3} \oplus h(A_1 A_3) \oplus c_1$
		\item $c_2 = f(r_{1,3} \oplus h(A_1 A_3))$
	\end{itemize} 
\end{itemize}

\subsubsection{Encoding all Possible Permutations}
We now have all the tools needed to encode the possible 
strings that can be formed from the strings of a PCP.\\
Steps:
\begin{enumerate}
	\item We start with two sets of sessions, one for the 
	$A$ strings of the PCP, and one for the $B$ strings.
	\item Each string is encoded in the method described above.
	\item Remove the initial oracle introduced IV from each 
	session. 
	\item After encoding one or more strings we add a special 
	nonce to the end of the strings that encodes the index's of the strings concatenated together. The nonce used 
	to encode the index in the $A$ strings must be the same nonce
	for the same index in the $B$ strings. For example, 
	$A_1A_3$ use the nonce '$13$', and $B_1B_3$ would use the same
	nonce '$13$'. In this way only encodings of the $A$ strings with the same nonce as those strings in $B$ could be unified.
	\item After encoding an index, check if the cypher block can be unified. If yes, then stop. If not, remove the nonce, as described above. Start new sessions, one for each new index. 
	For example, if you encoded $A_1$, you would then create 
	sessions for $A_1A_1$ and sessions for 
	$A_1A_2$ and $A_1A_3$. 
\end{enumerate}

Notice that any possible string formed from the initial PCP strings 
can be encoded into a cypher block. Only those blocks sharing the
same index nonce from the $A$ strings and $B$ strings can be unified.
If there is a unifier there is a solution to the PCP. 


\subsubsection{Dealing with $IV$}\label{sec_iv}
We need in several cases to remove the $IV$, either to chain 
sessions without including a new $IV$ or to ensure two 
different sessions have the same fake $IV$. More information on these methods are below. Here we describe how to replace the $IV$ added
to the block $C_1 = (p_1 \oplus IV)$. 
\begin{align*}
p_1 &= 0\\
c_1 &= f(0 \oplus IV) = f(IV)\\
p_2 &= c_1\\
c_2 &= f(c_1 \oplus c_1) = f(0)
\end{align*}
Notice that if we want to simulate something like an $IV$, but
that we know, we could replace $0$ in the above interaction 
with some nonce $k$. This will be useful when we want two 
sessions to have the same starting nonce. 


\subsubsection{Dealing with $IV$ without a $h()$:}\label{sec_iv}
We need in several cases to remove the $IV$, either to chain 
sessions without including a new $IV$ or to ensure two 
different sessions have the same fake $IV$. More information on these methods are below. Here we describe how to replace the $IV$ added
to the block $C_1 = (p_1 \oplus IV)$. 
\begin{align*}
p_1 &= 0\\
c_1 &= f(0 \oplus IV) = f(IV)\\
p_2 &= c_1\\
c_2 &= f(c_1 \oplus c_1) = f(0)
\end{align*}
Notice that if we want to simulate something like an $IV$, but
that we know, we could replace $0$ in the above interaction 
with some nonce $k$. This will be useful when we want two 
sessions to have the same starting nonce. 

\subsubsection{Encoding strings without a $h()$:}
We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
setting each character of the string as a plaintext block 
and sending each to the oracle from left to right, one at a 
time. For example,  $A_i = a_1 a_2 a_3 a_4$:
\begin{align*}
p_1 &=a_1\\
c_1 &=f(a_1 \oplus IV)\\
p_2 &=a_2\\
c_2 &=f(a_2 \oplus c_1)\\
&\ldots\\
c_4 &=f(a_4 \oplus c_3)
\end{align*}

\subsubsection{Chaining multiple strings without a $h()$:}
We also need to chain together the encodings of two or more strings. For example, if we wanted to encode $A_1A_2$. We
could just encode them in the same session but it will be
useful below to start a new session when concatenating 
a string onto the end of another string. We do this as 
follows:
\begin{itemize}
	\item Suppose we have two string $A_1 = a_{11}a_{12}$, and 
	$A_2 =a_{21}a_{22}$.
	\item Encoding the first string we get 
	$c^1_2 = f(a_{12} \oplus f(a_{11}\oplus IV))$.
	\item Start a second session and remove the $IV$:
	\begin{align*}
	c^2_1 &= f(0 \oplus IV) = f(IV)\\
	c^2_2 &= f(c^2_1 \oplus c^2_1) = f(0)\\
	c^2_3 &= f(a_{21} \oplus c^1_2 \oplus c^2_2 \oplus c^2_2) =
	f(a_{21} \oplus c^1_2)
	\end{align*}
\end{itemize} 

\subsubsection{Adding/Removing a final nonce to encode the index without a $h()$:}
After we have encoded one or more strings together we can 
add a nonce that is used to indicate the index of the encoded
strings and there order. For example, if we encode $A_1A_3$, 
we can add a nonce, '$13$' to a final cypher block. Notice
when we encode $B_1B_3$ we can add the same final nonce. This
ensures that only strings with the same index could possibly 
be unified since only these strings will have matching final 
nonces. 

nonces can then be removes by applying the same method above.
This allows us to remove a nonce, concatenate another string 
onto the encoding, add a new nonce indicating the new index, 
test for unifiability.

\subsubsection{Encoding all possible permutations without a $h()$:}
We now have all the tools needed to encode the possible 
strings that can be formed from the strings of a PCP.\\
Steps:
\begin{enumerate}
	\item We start with two sets of sessions, one for the 
	$A$ strings of the PCP, and one for the $B$ strings.
	\item Each string is encoded in the method described above.
	\item Remove the initial oracle introduced IV from each 
	session. 
	\item After encoding one or more strings we add a special 
	nonce to the end of the strings that encodes the index of the 
	index of the strings concatenated together. The nonce used 
	to encode the index in the $A$ strings must be the same nonce
	for the same index in the $B$ strings. For example, 
	$A_1A_3$ use the nonce '$13$', and $B_1B_3$ would use the same
	nonce '$13$'. In this way only encodings of the $A$ strings with the same nonce as those strings in $B$ could be unified.
	\item After encoding a an index, check if the cypher block can be unified. If yes, then stop. If not, remove the nonce, as described above. Start new sessions, one for each new index. 
	For example, if you encoded $A_1$, you would then continue this
	sessions for $A_1A_1$ and start two new sessions for 
	$A_1A_2$ and $A_1A_3$. 
\end{enumerate} 

\subsection{The Active Adversary $MOE_{\oplus}$-decision problem for bound Sessions of bound Length}
The first decision problem to consider is the $MOE_{\oplus}$
problem with a finite bound on both the number of sessions and
the sessions lengths. 
For both schedules and both $MOE$s, $CBC$ and $CFB$, the problem
reduces to the $MOE$-unification problem for $E=xor$. This problem
has been solved in the positive [Chris and Hia Paper].

\subsection{The Active Adversary $MOE_{\oplus}$-decision problem for Arbitrary Sessions of Arbitrary Length and a $h()$ function}
Let's now consider the $MOE_{\oplus}$-decision problem
for an active adversary, unbounded number of sessions, and unbounded session lengths. In addition, we assume the adversary has the ability 
to use a hash function, $h()$.
 
\begin{theorem}\label{thm:unbounded_unbounded}
The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
sessions, unbounded session lengths, immediate schedule, and CBC. 
\end{theorem}
\begin{proof}\todo{Andrew: Need to improve the proof}
	\textit{Claim 1:} These exists a unifier to two cypher blocks
	of the MOE program described in Section~\ref{sec:encoding} iff
	there is a solution to the corresponding PCP.
	\noindent
	\text{Claim Proof Sketch:}\\
	If there is a unifier it has to be between two string encoded 
	with the same index from the upper and lower parts of the PCP
	due to the unique nonces encoding the index and the position encoding.
	If there is a solution to the PCP, that solution will evidentially
	be encoded into two sessions that are unifiable. 
\end{proof}

\begin{example}
	Consider the following PCP:
	\[
	(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
	\]
	The solution for this basic PCP problem is $1,3$.
	
	We would start with two sets of sessions, one for the 
	upper strings. $ba, ~ab, ~aaa$, and one for the lower
	strings, $baa, ~ba, ~aa$. One session for each of the initial strings. 
	
	\noindent
	$A$ Sessions:
	\begin{enumerate}
		\item Session1, string ``ba'':
		\begin{align*}
		p_1 &= 0\\
		c^{A1}_1 &= f(0 \oplus IV_{1})\\
		p_2 &= r_1 \oplus h(b) \oplus h^2(a) \oplus c^{A1}_1\\
		c^{A1}_2 &= f(r_1 \oplus h(b) \oplus h^2(a) \oplus c^{A1}_1 \oplus c^{A1}_1) = f(r_1 \oplus h(b) \oplus h^2(a))
		\end{align*}
		\item Session2, string ``ab'':
		\begin{align*}
			c^{A2}_2 &=f(r_2 \oplus h(a) \oplus h^2(b))
		\end{align*}
		\item Session3, string ``aaa'':
		\begin{align*}
			c^{A3}_2 &=f(r_3 \oplus h(a) \oplus h^2(a) \oplus h^3(a))
		\end{align*}
	\end{enumerate}
	
	\noindent
	$B$ Sessions:
\begin{enumerate}
	\item Session1, string ``baa'':
	\begin{align*}
	c^{B1}_2 &= f(r_1 \oplus h(b) \oplus h^2(a) \oplus h^3(a))
	\end{align*}
	\item Session2, string ``ba'':
	\begin{align*}
	c^{B2}_2 &= f(r_2 \oplus h(b) \oplus h^2(a))
	\end{align*}
	\item Session3, string ``aa'':
	\begin{align*}
	c^{B3}_2 &= f(r_3 \oplus h(a) \oplus h^2(a))
	\end{align*}
\end{enumerate}
 
Now try if we look for unifiers of the above cypher blocks, 
$c^{A1}_2, ~c^{A2}_2, ~c^{A3}_2, ~c^{B1}_2, ~c^{B2}_2, ~c^{B3}_2$.
We don't find a unifier so we move on to test the next level of
possible strings, those with index: $11, 12, 13, 21, 22, 23, 31, 32, 33$. For these we first remove the current nonce encoding an index, 
then concatenate the two strings, and then add the new nonce for the
new index.  To save space we will just show this process for 
the index $1,3$ (the solution) for the $A$ sessions and the $B$ sessions.

SessionA, string `$A_1A_2 = ba \cdot aaa$:
\begin{align*}
p_1 &= 0\\
c^{A}_1 &= f(0 \oplus IV_{1})\\
p_2 &= r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a) \oplus c^{A}_1\\
c^{A}_2 &= f(r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a))\\
\end{align*}
SessionB, string `$B_1B_2 = baa \cdot aa$:
\begin{align*}
p_1 &= 0\\
c^{B}_1 &= f(0 \oplus IV_{2})\\
p_2 &= r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a) \oplus c^{B}_1\\
c^{B}_2 &= f(r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a))\\
\end{align*}

Now if we check for unifiers we find one for $c^{A}_2$ and 
$c^{B}_2$, which corresponds to the PCP solution $1,3$.
 
 
\end{example}



 
\subsection{The Active Adversary $MOE_{\oplus}$-decision problem for Arbitrary Sessions of Arbitrary Length, and no $h()$ function}
In this section we assume the adversary is active but doesn't have
the ability to apply the $h()$ function.
apply the $h()$ function. For this approach to work we need to make the following assumptions:
\begin{enumerate}
	\item The adversary decides when it wants to check if cypher
	blocks are unifiable.
	\begin{itemize}
		\item That is, the adversary does not have to check 
		for unifiers every time a cypher block is revived back from
		the oracle.   
	\end{itemize}
	\item The adversary can decide what blocks to try to unify.
	\begin{itemize}
		\item When checking for unifiers the adversary doesn't have to
		check all pairs of cypher blocks for unifiers but only those
		pairs he is interested in. 
	\end{itemize} 
\end{enumerate}

Based on these assumptions we can construct a different reduction from
the PCP to the $MOE_{\oplus}$-decision problem. 


\subsubsection{$MOE_{\oplus}$ decision problem for unbounded 
	sessions and unbounded session lengths}
\begin{theorem}\label{thm:unbounded_unbounded}
	The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
	sessions, unbounded session lengths, immediate schedule, and CBC. 
\end{theorem}
\begin{proof}
\end{proof}

\begin{example}
	Consider the following PCP:
	\[
	(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
	\]
	The solution for this basic PCP problem is $1,3$.
	
	We would start with two sets of sessions, one for the 
	upper strings. $ba, ~ab, ~aaa$, and one for the lower
	strings, $baa, ~ba, ~aa$. One session for each of the initial strings. 
	
	\noindent
	$A$ Sessions:
	\begin{enumerate}
		\item Session1, string ``ba'':
		\begin{align*}
		p_1 &= 0\\
		c^{A1}_1 &= f(0 \oplus IV_{1})\\
		p_2 &= b \oplus c^{A1}_1\\
		c^{A1}_2 &= f(b \oplus c^{A1}_1 \oplus c^{A1}_1)\\
		p_3 &= a\\
		c^{A1}_3 &= f(a \oplus c^{A1}_2)\\
		&\text{Add the nonce for the index, 1 in this case}\\
		c^{A1}_4 &=f(1, \oplus c^{A1}_3)
		\end{align*}
		\item Session2, string ``ab'':
		\begin{align*}
		c^{A2}_3 &= f(b \oplus c^{A2}_2)\\
		&\text{Add the nonce for the index, 2 in this case}\\
		c^{A2}_4 &=f(2, \oplus c^{A2}_3)
		\end{align*}
		\item Session3, string ``aaa'':
		\begin{align*}
		c^{A3}_4 &= f(a \oplus c^{A3}_3)\\
		&\text{Add the nonce for the index, 3 in this case}\\
		c^{A3}_5 &=f(3, \oplus c^{A3}_4)
		\end{align*}
	\end{enumerate}
	
	\noindent
	$B$ Sessions:
	\begin{enumerate}
		\item Session1, string ``baa'':
		\begin{align*}
		c^{B1}_4 &= f(a \oplus c^{B1}_3)\\
		&\text{Add the nonce for the index, 1 in this case}\\
		c^{B1}_5 &=f(1, \oplus c^{B1}_4)
		\end{align*}
		\item Session2, string ``ba'':
		\begin{align*}
		c^{B2}_3 &= f(a \oplus c^{B2}_2)\\
		&\text{Add the nonce for the index, 2 in this case}\\
		c^{B2}_4 &=f(2, \oplus c^{B2}_3)
		\end{align*}
		\item Session3, string ``aa'':
		\begin{align*}
		c^{B3}_3 &= f(a \oplus c^{B3}_2)\\
		&\text{Add the nonce for the index, 3 in this case}\\
		c^{B3}_4 &=f(3, \oplus c^{B3}_3)
		\end{align*}
	\end{enumerate}
	
	Now try if we look for unifiers of the above cypher blocks, 
	$c^{A1}_4, ~c^{A2}_4, ~c^{A3}_5, ~c^{B1}_5, ~c^{B2}_4, ~c^{B3}_4$.
	We don't find a unifier so we move on to test the next level of
	possible strings, those with index: $11, 12, 13, 21, 22, 23, 31, 32, 33$. For these we first remove the current nonce encoding an index, 
	then concatenate the two strings, and then add the new nonce for the
	new index.  To save space we will just show this process for 
	the index 1,3 (the solution) for the $A$ session.
	
	Session1, string ``ba'':
	\begin{align*}
	p_1 &= 0\\
	c^{A1}_1 &= f(0 \oplus IV_{1})\\
	p_2 &= b \oplus c^{A1}_1\\
	c^{A1}_2 &= f(b \oplus c^{A1}_1 \oplus c^{A1}_1)\\
	p_3 &= a\\
	c^{A1}_3 &= f(a \oplus c^{A1}_2)\\
	&\text{Add the nonce for the index, 1 in this case}\\
	c^{A1}_4 &=f(1, \oplus c^{A1}_3)\\
	&\text{end of encoding of string 1, ``ba''}\\
	&\text{start a new session to add string ''aaa''}\\
	p_1 &= 0\\
	c^{A1,3}_1 &= f(0 \oplus IV)\\
	p_2 &= a \oplus c^{A1}_3 \oplus c^{A1,3}_1\\
	c^{A1,3}_2 &= f(a \oplus c^{A1}_3 \oplus c^{A1,3}_1 \oplus c^{A1,3}_1 ) = \\ f(a \oplus c^{A1}_3) \\
	&\ldots \\
	c^{A1,3}_4 &= f(a \oplus c^{A1,3}_3) \\
	&\text{Add the new index 1,3}\\
	c^{A1,3}_5 &= f(13 \oplus c^{A1,3}_4) \\
	\end{align*}
	Notice that for the string in the $B$ sessions with index $1,3$ we get
	$c^{B1,3}_5 = f(13 \oplus c^{B1,3}_4)$.
	
	Now if we check for unifiers we find one for $c^{A1,3}_5$ and 
	$c^{B1,3}_5$, which corresponds to the PCP solution $1,3$.
	
	
\end{example}	

\subsection{Finite Length with Arbitrary Sessions}

\begin{lemma}\label{lemma:sim_arbitrary_length}
	Given a $MOE_{\oplus}$ program with sessions of fixed length,
	sessions of arbitrary length can be simulated provided 
	an arbitrary number of sessions can be created. 	
\end{lemma}
\begin{proof}
	Suppose there is a bound, $n$, on the length of a sessions, 
	i.e., the number of cypher blocks per session. Suppose you wanted to continue a session beyond the bound, create a $c_{n+1}$ from 
	a $c_{n}$. You need to create a new sessions, remove the 
	new $IV$ (as is done above), add $c_{n}$, and continue. 
	Provided you have an arbitrary number of sessions this can continue
	providing arbitrary length for sessions. 
\end{proof}

\begin{theorem}\label{thm:bounded_unbounded}
	The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
	sessions, bounded session lengths, immediate schedule, and CBC.	
\end{theorem}
\begin{proof}
	From Lemma~\ref{lemma:sim_arbitrary_length} 
	and Theorem~\ref{thm:unbounded_unbounded}.
\end{proof}

\subsection{Finite Sessions of Arbitrary Length}
\begin{lemma}\label{lemma:sim_arbitrary_sessions}
	Given a $MOE_{\oplus}$ program with sessions of arbitrary length
	and a bounded number of sessions,
	an unbounded number of sessions can be simulated. 	
\end{lemma}
\begin{proof}
	Suppose there is a bound, $n$, on the number of sessions. Suppose you wanted to create a new, $n+1$, session. We can add a new
	session to an existing one by doing the following: 
	remove the old cypher block, add a random nonce, and the 
	first plain text of the new session. Notice if you want to 
	continue the old session, just repeat the steps but add 
	the old cypher test as the first plain text.  
\end{proof}  


\begin{theorem}\label{thm:unbounded_bounded}
	The $MOE_{\oplus}$ decision problem is undecidable for bounded 
	sessions, unbounded session lengths, immediate schedule, and CBC.	
\end{theorem}
\begin{proof}
	From Lemma~\ref{lemma:sim_arbitrary_sessions} 
	and Theorem~\ref{thm:unbounded_unbounded}.
\end{proof}

\section{Decision Problems with an Oracle Encoding the PCP}
In this section we consider the case where the adversary is passive, 
it doesn't attempt to encode the PCP and simply applies the unification
algorithm whenever it receives a cypher block. Here the oracle will
attempt to encode the PCP strings and then pass the encodings in cypher blocks back to the oracle. We consider the same 
undecidable sub-cases as above, unbounded sessions and lengths, bounded sessions and unbounded lengths, and unbounded sessions and bounded lengths. In each of these cases the problem remains undecidable.

First we explore the string encoding methods.
\subsection{String Encoding Methods}\label{sec:encoding}
Consider an arbitrary PCP problem:
\[
(\frac{A_1}{B_1}),~(\frac{A_2}{B_2}), ~\ldots, ~(\frac{A_n}{B_n})
\]
over an alphabet $\Sigma=\{a, b\}$. 
\ignore{
	%%%OLD DEF
	We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
	setting each character of the string as a plaintext block 
	and sending each to the oracle from left to right, one at a 
	time. For example,  $A_i = a_1 a_2 a_3 a_4$:
	\begin{align*}
	p_1 &=a_1\\
	c_1 &=f(a_1 \oplus IV)\\
	p_2 &=a_2\\
	c_2 &=f(a_2 \oplus c_1)\\
	&\ldots\\
	c_4 &=f(a_4 \oplus c_3)
	\end{align*}
	%%%End of Old Def
}

\subsubsection{String Encodings with a $h()$ function}
The first method for encoding strings assumes we have a
hash function, $h()$, which can be used to enforce 
positions of characters in the strings. 
We encode a string $A_i = a_1 a_2 a_3 a_4$ by 
first using repeated applications of $h()$ to first encode
the position of that character in the string. For example,
$h^1(a_1), ~h^2(a_2), ~h^3(a_3), h^4(a_4)$.
We then combine each character in the string via $\oplus$,
$h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4)$. 


\subsubsection{String Index and Cypher Block Encoding}

For example, consider the string ``$a_1a_2a_3a_4$'' and assume
this string is contained in the ith block of the CPC problem.
Then the oracle can select an $IV$ that corresponds to a nonce, $r_i$, which will ensure only strings with the same index can be unified.
\begin{itemize}
	\item $p_1 = x_1$
	\item $c_1 = f(IV)$. 
	\item $p_2 = x_2$
	\item $c_2 = 
	f(h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4) 
	\oplus f(IV))$. 
\end{itemize} 


\subsubsection{Chaining Multiple String}
Suppose we want to now encode the new string $A_1 A_3$.
This encoding can be done as follows:
\begin{itemize}
	\item Encode the character positions using $h()$ in
	$A_1$ concatenated with $A_2$. 
	Denote these as $h(A_1A_3)$
	respectively. 
	\item Select an IV to denote the index of the string $A_1 A_3$,
	$IV = 13$.
	\item Encode the string into a cypher block and add the IV representing the index $1,3$, denotes this nonce as $r_{13}$.
	\begin{itemize}
		\item $p_2= r_{1,3} \oplus h(A_1 A_3) \oplus c_1$
		\item $c_2 = f(h(A_1 A_3) \oplus f(r_{1,3}))$
	\end{itemize} 
\end{itemize}

\subsubsection{Simulating multiple sessions in a single session}
Unlike the active adversary case, the oracle cannot create new
sessions. Therefore using a new session for each possible string 
index is not possible since we cannot ensure the creation 
of sessions when needed. However, it is possible to simulate
multiple sessions with a single session of arbitrary length.
Suppose we have single session encoding the string $A_i$ and 
now the oracle wants to create two new strings $A_iA_j$ and 
$A_iA_k$ to simulate. Suppose we are at cipher block $c_n$ 
in the sessions. That is, the adversary has sent $p_n =x_n$.
then $c_n$ is the encoding of $h(A_i A_j)$ with a new IV,
$r_{ij}$. Next, $c_{n+1}$ is the encoding of $A_iA_k$ with a
new IV, $r_{ik}$. 

\subsubsection{Encoding all Possible Permutations}
We now have all the tools needed to encode the possible 
strings that can be formed from the strings of a PCP. 
However, we need at least two sessions of arbitrary length.
The first session is used to encode the upper strings of the 
PCP and the second session the lower strings. 
Steps:
\begin{enumerate}
	\item We start with two sessions, one for the 
	$A$ strings of the PCP, and one for the $B$ strings.
	\item Each string is encoded in the method described above.
	\item The oracle adds a special 
	nonce to the end of the strings that encodes the index's of the strings concatenated together. The nonce used 
	to encode the index in the $A$ strings must be the same nonce
	for the same index in the $B$ strings. For example, 
	$A_1A_3$ use the nonce '$13$', and $B_1B_3$ would use the same
	nonce '$13$'. In this way only encodings of the $A$ strings with the same nonce as those strings in $B$ could be unified.
	\item Each cypher block sent back to the adversary will only be able to be unified with a block with the same index. 
	If no unifier is found then the index is increased and the 
	new strings are encoded, as described above, and sent back to
	the adversary.  
\end{enumerate}

Notice that any possible string formed from the initial PCP strings 
can be encoded into a cypher block. Only those blocks sharing the
same index nonce from the $A$ strings and $B$ strings can be unified.
If there is a unifier there is a solution to the PCP. 


\subsection{$MOE_{\oplus}$ decision problem for unbounded 
	sessions and unbounded session lengths}
\begin{theorem}\label{thm:unbounded_unbounded}
	The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
	sessions, unbounded session lengths, immediate schedule, and CBC. 
\end{theorem}
\begin{proof}
\end{proof}

\begin{example}
		Consider the following PCP:
		\[
		(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
		\]
		The solution for this basic PCP problem is $1,3$.
		
		We would start with two sessions, one for the 
		upper strings. $ba, ~ab, ~aaa$, and one for the lower
		strings, $baa, ~ba, ~aa$. 
		
		\noindent
		$A$ Session:
		\begin{enumerate}
			\item Session1, strings ``ba'', ``ab'', and ``aaa'':
			\begin{align*}
			p_1 &= x_1\\
			c^{A1}_1 &= f(h(b) \oplus h^2(a) \oplus r_1)\\
			p_2 &= x_2\\
			c^{A1}_2 &= f(h(a) \oplus h^2(b) \oplus r_2)\\
			p_3 &= x_3\\
			c^{A1}_3 &= f(h(a) \oplus h^2(a) \oplus h^3(a) \oplus r_3)
			\end{align*}
		\end{enumerate}
		
		\noindent
		$B$ Sessions:
		\begin{enumerate}
			\item Session1, string ``baa'', ``ba'', and ''aa'':
			\begin{align*}
			p_1 &= x_1\\
			c^{B1}_1 &= f(h(b) \oplus h^2(a) \oplus h^3(a) \oplus r_1)\\
			p_2 &= x_2\\
			c^{B1}_2 &= f(h(b) \oplus h^2(a) \oplus r_2)\\
			p_3 &= x_3\\
			c^{B1}_3 &= f(h(a) \oplus h^2(a) \oplus r_3)
			\end{align*}
		\end{enumerate}
		
		We don't find a unifier so we move on to test the next level of
		possible strings, those with index: $11, 12, 13, 21, 22, 23, 31, 32, 33$. To save space we will just show this process for 
		the index 1,3 (the solution) for the $A$ session and the 
		$B$ session.
		
		Session1, string ``ba'' combined with string ``aaa'':
		\begin{align*}
		p_1 &= n\\
		c^{A1}_n &= f(h(b) \oplus h^2(a) 
		\oplus h^3(a) \oplus h^4(a) \oplus h^5(a)
		 \oplus r_{1,3})\\
		\end{align*}
		Notice that for the string in the $B$ sessions with index $1,3$ we get
		$c^{B1}_n= f(h(b) \oplus h^2(a) 
		\oplus h^3(a) \oplus h^4(a) \oplus h^5(a)
		\oplus r_{1,3})$.
		
		Now if we check for unifiers we find one for $c^{A1}_n$ and 
		$c^{B1}_n$, which corresponds to the PCP solution $1,3$.
		
\end{example}
\subsection{The Active Adversary $MOE_{\oplus}$-decision problem for Arbitrary Sessions of Arbitrary Length, and no $h()$ function}

Note that the same string encoding $f(h(b) \oplus h^2(a) 
\oplus h^3(a) \oplus h^4(a) \oplus h^5(a)
\oplus r_{1,3})$ can be encoded without the $h()$ but still enforcing
positions in the following way: 
$f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus r_{1,3})))))$ 
this leads to the following result.

\begin{theorem}\label{thm:bounded_unbounded}
	The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
	sessions, bounded session lengths, immediate schedule, and CBC.	
\end{theorem}
\begin{proof}
\end{proof}
\vfill
\pagebreak
\subsection{Example}
Consider the following PCP:
\[
(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
\] 
Assume that the oracle has only a single session initiated by the 
adversary in which to encode the above problem. Assume also that the
$MOE$ is CBC and the schedule is immediate.  

The encoding is done as follows:
\begin{itemize}
	\item The oracle encode the strings of the PCP using a canonical ordering
	of the strings representing the index of the PCP strings. 
	For example, 
	$1, ~2, ~3, ~11, ~12, ~13, ~21, ~22, ~23, ~31, ~32, ~33, ~111, 
	\ldots$.  
	\item For each index in the above ordering the oracle encodes
	two cipher blocks, one which encodes the upper string from the 
	PCP for that index and one that encodes the lower strings.
	There are two possible encoding methods we could selected, 
	one using the $h()$ function and one without. 
	For example:
	\begin{itemize}
		\item For the index $13$ the two possible encodings for the
		upper strings would be: 
		\begin{enumerate}
			\item $f(b \oplus f(a \oplus f(a \oplus f(a \oplus
			f(a \oplus r_{13})))))$.
			\item $f(h(b) \oplus h^2(a) \oplus h^3(a) \oplus 
			h^4(a) \oplus h^5(a) \oplus r_{13})$
		\end{enumerate}
		\item For the index $13$ the two possible encodings for the
		lower strings would be: 
		\begin{enumerate}
			\item $f(b \oplus f(a \oplus f(a \oplus f(a \oplus
			f(a \oplus r_{13})))))$.
			\item $f(h(b) \oplus h^2(a) \oplus h^3(a) \oplus 
			h^4(a) \oplus h^5(a) \oplus r_{13})$
		\end{enumerate}
		\item the $r_{13}$ nonce is added to the both the upper and 
		lower encodings for the index $13$ and likewise for all other
		index. Thus only cipher blocks encoding strings with the same index can be unified. 
	\end{itemize}
	\item For each plain text sent by the adversary the oracle ignores the plain text and sends the next cipher block in the above
	canonical sequence. Thus it takes two steps to send each index
	in the sequence since there are two cipher blocks for each index, 
	one for the upper strings and one for the lower.
	\item The adversary finds a unifier for two blocks iff there
	is a solution to the PCP.
	\begin{itemize}
		\item Only upper and lower strings with the same index will 
		have the same nonce and thus be the only possible 
		unifiable cipher blocks. 
		\item All possible strings will eventually be encoded 
		with a session of arbitrary length.  
	\end{itemize}
\end{itemize}

\section{Pair Encodings by the Oracle}

In this section we look at another possible encoding, where 
the oracle sends multiple cipher blocks back to the
adversary each turn. The encoding is done as follows:
\begin{itemize}
	\item The $f$-encoding of a string $s = a_1 \cdot a_2 \cdot ~\ldots ~\cdot a_n$, denoted as $f(\bigoplus s)$, is 
	$f(a_1 \oplus f(a_2 \oplus \ldots f(a_n \oplus C_j) \ldots ))$, where $C_j$ is a cipher block containing the $f(\bigoplus s')$ 
	encoding of another string $s'$ or a nonce.
	\item Each turn the oracle encodes and return two cipher blocks. $A_i$ and $B_i$, where $A_i$ is a cipher block $f$-encoding of upper strings of the PCP, and $B_i$ the $f$-encoding of lower strings.
	$C_0 = [A_0,B_0]$, where $A_0$ is the $f$-encoding of a 
	upper string in the PCP and $B_0$ the corresponding lower string.
	The only difference for these initial encodings is the inclusion of a random nonce, $r$, instead of a prior block. More details:
	\begin{itemize}
		\item $A_i =f(a_1 \oplus f(a_2 \oplus \ldots f(a_n \oplus C_{i-1, 1}) \ldots )) $
		\item $B_i =f(b_1 \oplus f(b_2 \oplus \ldots f(b_m \oplus C_{i-1, 2}) \ldots )) $
		\item For $A_0$, $C_{i-1, 1}=r$, where $r$ is a random nonce.
		\item For $B_0$, $C_{i-1, 2}=r$, where $r$ is a random nonce.
	\end{itemize}  
	\item For each pair of cipher block, $A_i$ and $B_i$, we
	use $C_i$ to represent the pair. We distinguish the cipher blocks of the pair by a subscript. For example, if $C_i = A_i, B_i$, then 
	$C_{i,1} = A_i$ and $C_{i,2} = B_i$.
	 
\end{itemize}

The interaction works as follows:
\begin{enumerate}
	\item The adversary sends $P_i$.
	\item The oracle ignores $P_i$ and sends back $C_i$. 
	\item The adversary attempts to unify $C_{i, 1}$ with 
	$C_{i,2}$. The adversary is successful and the interaction 
	stops if a unifier is found.
\end{enumerate}

\begin{theorem}
		The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
		sessions, bounded session lengths, immediate schedule, and CBC.
\end{theorem}
\begin{proof}
	\textbf{Sketch:}\\
	Notice that for any string produced by the combination
	of strings from a PCP, there will be a cipher block $C_i$ that
	is the $f$-encoding of that string. Furthermore, 
	$C_{i,1}$ will encode the upper strings and $C_{i,2}$ will
	encode the lower strings. 
	
	Then, there exists a unifier of $C_{i,1} =^{?} C_{i,2}$ iff
	the encoded strings are a solution to the PCP.  
\end{proof}

\begin{example}
Consider the following PCP:
\[
(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
\] 
A solution to this problem is $1,3$. Notice that we get that 
encoded in the following cipher block.

The first possible ``initial blocks'':
\begin{align*}
C^1_0 &= f(b \oplus f(a \oplus r_1)), ~f(b \oplus f(a \oplus f(a \oplus r_1)))\\
C^2_0 &= f(a \oplus f(b \oplus r_2)), ~f(b \oplus f(a \oplus r_2))\\
C^3_0 &= f(a \oplus f(a \oplus f(a \oplus r_3))), ~f(a \oplus f(a \oplus r_3))\\
\end{align*}

Some of the possible blocks encoding two strings:
 
\end{example}
\begin{align*}
C^{1,3}_i &= f(a \oplus f(a \oplus f(a, C^3_{0, 1}))), ~f(a \oplus f(a \oplus C^3_{0, 2})), \text{ Encoding the string index 3,1}\\
C^{2,3}_j &= f(a \oplus f(a \oplus f(a \oplus C^2_{0, 1}))), ~f(a \oplus f(a \oplus C^2_{0, 2})), \text{ Encoding the string index 3,2}\\
C^{3,1}_k &= f(b \oplus f(a \oplus C^3_{0, 1}))), ~f(b \oplus f(a \oplus f(a \oplus C^3_{0, 2}))), \text{ Encoding the string index 1,3}\\
\end{align*}

Notice that there is a solution, $1,3$, since 
$C^{3,1}_{k, 1} = f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus r_3))))))$
 and 
$C^{3,1}_{k, 2} = f(b \oplus f(a \oplus f(a \oplus f(a \oplus f(a \oplus r_3)))$ 

}
\end{document}
