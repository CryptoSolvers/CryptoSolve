\documentclass{llncs}

\usepackage{amssymb}
\usepackage{proof}
%\usepackage{hyperref}
\usepackage{url}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{latexsym, graphics, graphicx}
\usepackage{color}
\usepackage{epsfig, amssymb}
\usepackage{yfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{float}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{marginnote}
\usepackage{mathtools}
\usepackage{todonotes}



\newtheorem{assumption}{Assumption}

\newcommand{\pa}{{\bf Pair}}
\newcommand{\enc}{{\bf Enc}}
\newcommand{\eq}{\mathcal{EQ}}
\newcommand{\bphi}{\ovr{\phi}}
\newcommand{\bh}{\ovr{h}}
\newcommand{\tdh}{\tilde{h}}
\newcommand{\ignore}[1]{}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}

%\newcommand{\ISFULL}

\ifdefined\ISFULL
\newcommand{\FULL}[1]{#1}
\newcommand{\SHORT}[1]{}
\else
\newcommand{\FULL}[1]{}
\newcommand{\SHORT}[1]{#1}
\fi



\title{ $MOE$ Decision Problems}


\pagestyle{empty}

\begin{document}

\maketitle
\begin{abstract}
The $MOE$ decision problem. 

\end{abstract}

\section{Definitions}

\begin{definition}
	$MOE$-terms: Given a first-order signature $\Sigma$, a countable set of (free) constants (names) $N$, such that $\Sigma \cap N =\emptyset$, and a (countable) set of variables $X$, the set of $MOE$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$. 
\end{definition}



\begin{definition}
	$MOE$-Program: Is an interaction between the 
	the adversary and the oracle consisting of the following actions
	and orders. Let $c$ be a name representing a session identifier.
	\begin{enumerate}
		\item $start(c)$. The start of a session $c$, sent from the
		adversary to oracle.
		\item $stop(c)$. The end of session $c$.
		\item $block(c, x)$. A new block in session $c$ sent from
		the adversary to the oracle. This is to be encrypted by the 
		oracle. This variable, $x$, represents possible messages, via
		instantiation, that the adversary could send during a program
		run. 
		\item $send(c, m)$. The oracle send a $MOE$-term, $m$, back
		to the adversary. The variables of $m$ must have been 
		previously contained in a received $block(c, x)$ message
		that occurred before the $send(c, m)$ message.
	\end{enumerate} 
\end{definition}
This ordering in the last item will be important to the decision 
problems. We can more compactly represent the sequence of messages
in a $MOE$-program as a frame. 

\begin{definition}
		$MOE$-frame:  $\phi = \nu \tilde{n}.\sigma$, where
		$\tilde{n}$ is a set of names representing non-free variables such as random nonces. $\sigma$ is a substitution
		such that $Dom(\sigma) = \{ y_1, y_2, \ldots, y_n\}$,
		$Dom(\sigma) \cap \tilde{n} = \emptyset$, and
		$Ran(\sigma)$ are $MOE$-terms.  
\end{definition}

A $MOE$-frame models a trace of a $MOE$ program in the following way:
if the $i$th action of the challenger in the trace is 
$Rcv\_Block(t)$ or $Send(t)$, where $t$ is a $MOE$-term, 
then there is a variable $y_i \in Dom(\sigma)$ and 
$y_i \sigma \mapsto t$. Random variables such as the IV are 
modeled as names and placed in $\tilde{n}$.

The terms of the frame are further restricted depending on the mode of encryption being modeled and the schedule used by the oracle to
return cipher blocks to the adversary. These restrictions have
the following impact on the $MOE$-frames:
\begin{itemize}
	\item $MOE$: The mode of encryption dictates how the oracle 
	constructs cypher blocks. For example, in a CyberBlock Chaining,
	$CBC$, $MOE$ the ith block of cipher text, $C_i$, is modeled by
	the $y_i \mapsto f(C_{i-1} \oplus x_i)$, where $\oplus$ is
	the xor function.
	\item Schedule: The oracle can either return the 
	cipher blocks immediately or at the end of the session.  
\end{itemize}

The adversary has the ability to execute multiple simultaneous session with the oracle. In this case the initial name, the IV, will be fresh for each session. Each session can then be modeled by it's own frame. 


%\begin{definition}
%	Let 
%\end{definition}


\section{$MOE$ Decision Problems}

We model a potential attack via a decision problem involving unification. 

First we need a new definition of unification which includes the 
constraint on term orders imposed by the $MOE$-program. This 
ordering can be enforeced using a relation $\prec_{\mathcal{P}}$, defined 
as follows. 

\begin{definition}
	Let $\mathcal{P}$ be a $MOE$-program and $\phi = \nu \tilde{n}.\sigma$ the corresponding frame. We define a relation, 
	$\prec_{\mathcal{P}}$, by:
	\begin{itemize}
		\item $t \prec_{\mathcal{P}} x$,
		$y_i \mapsto x, ~y_j \mapsto t ~ \in \sigma$, and
		$ i < j$.
		\item $x_i \prec_{\mathcal{P}} x_j$ iff 
		 $y_i \mapsto x_i, ~y_j \mapsto x_j ~ \in \sigma$, and
		 $ i < j$.
		 \item If $\bar{t} \prec_{\mathcal{P}} x$, then 
		 $f(\bar{t}) \prec_{\mathcal{P}} x$, where $f \in \Sigma$.
		 \item $t \not \prec_{\mathcal{P}} x$ iff $t \prec_{\mathcal{P}} x$ does not hold.
	\end{itemize}
\end{definition}

We can now define the $MOE$ unification problem.

\begin{definition}
	Let $\mathcal{P}$ be a $MOE$-program and $\phi = \nu \tilde{n}.\sigma$ the corresponding frame. Let $t_1$ and $t_2$
	be two $MOE$-terms appearing in $\mathcal{P}$. $t_1$ and $t_2$
	are $\mathcal{P}$-unifiable iff there exists some substitution
	$\delta$ s.t.
	\begin{itemize}
		\item $\forall x \in Dom(\delta), ~x\delta \prec_{\mathcal{P}} x$.
		\item $t_1 \delta =_E t_2\delta$.
	\end{itemize}
\end{definition}


\begin{definition}\todo[inline]{Andrew: We need to improve this def}
	Decision Problem: We model an attack by the adversary being able
	to unify two terms, either from the same frame of from different
	frames.  
\end{definition}

Now that the general decision problem is defined, we can define several
instances of the problem based on the combination of the following factors:
\begin{itemize}
	\item The equational Theory $E$.
	\item The $MOE$.
	\item The Schedule.
	\item Bounds on the session length and number of sessions.  
\end{itemize}

We consider several of these possibilities in what follows.

First, we will consider the $E=xor$ equational theory and we 
will consider the following $MOE$. In these modes of encryption 
$\Sigma ={\oplus, 0, f}$, where $\oplus$ is xor and $f=enc(K,\_)$.
$IV$ is the initialization vector, the first block sent. 
\begin{itemize}
	\item Cipher Block Chaining $(CBC):$ The ith plain text is modeled via a term consisting of a single variable $x_i$. The initial cipher block, the IV, is modeled by a name, $r$. The ith block of cipher text, $C_i$, is modeled by a
	term $f(C_{i-1} \oplus x_i)$.
	\item Cipher Feedback $(CFB):$ The ith plain text is modeled via a term consisting of a single variable $x_i$. The initial cipher block is modeled by a name, $r$. The ith block of cipher text, $C_i$, is modeled by a
	term $f(C_{i-1}) \oplus x_i$.  
	\item Propagating Cipher Block Chaining ($PCBC$): 
	$C_1 = f(P_1 \oplus IV)$, $C_i = f(P_i \oplus P_{i-1} \oplus C_{i-1})$.
\end{itemize}

\subsubsection{Dealing with $IV$}\label{sec_iv}
We need in several cases to remove the $IV$, either to chain 
sessions without including a new $IV$ or to ensure two 
different sessions have the same fake $IV$. More information on these methods are below. Here we describe how to replace the $IV$ added
to the block $C_1 = (p_1 \oplus IV)$. 
\begin{align*}
	p_1 &= 0\\
	c_1 &= f(0 \oplus IV) = f(IV)\\
	p_2 &= c_1\\
	c_2 &= f(c_1 \oplus c_1) = f(0)
\end{align*}
Notice that if we want to simulate something like an $IV$, but
that we know, we could replace $0$ in the above interaction 
with some nonce $k$. This will be useful when we want two 
sessions to have the same starting nonce. 


\section{$MOE_{\oplus}$ Decision Problems}\todo[inline]{Andrew: approach that is perhaps easier}
We will first consider the xor equational theory. We can therefore refine the definition of $MOE$-term 
 
\begin{definition}
	$MOE_{\oplus}$-terms: Given a first-order signature $\Sigma=\{
	\oplus, 0, f, h\}$, a countable set of (free) constants (names) $N$, such that $\Sigma \cap N =\emptyset$, and a (countable) set of variables $X$, the set of $MOE_{\oplus}$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$. 
\end{definition}

\subsection{Finite Sessions of Finite Length}
The first decision problem to consider is the $MOE_{\oplus}$
problem with a finite bound on both the number of sessions and
the sessions lengths. 
For both schedules and both $MOE$s, $CBC$ and $CFB$, the problem
reduces to the $MOE$-unification problem for $E=xor$. This problem
has been solved in the positive [Chris and Hia Paper].

\subsection{String Encoding Methods}\label{sec:encoding}
In this section we describe how to encode string from 
a PCP into cypher blocks. Consider an arbitrary PCP problem:
\[
(\frac{A_1}{B_1}),~(\frac{A_2}{B_2}), ~\ldots, ~(\frac{A_n}{B_n})
\]
over an alphabet $\Sigma=\{a, b\}$. 

\subsubsection{Encoding strings}
\ignore{
	%%%OLD DEF
	We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
	setting each character of the string as a plaintext block 
	and sending each to the oracle from left to right, one at a 
	time. For example,  $A_i = a_1 a_2 a_3 a_4$:
	\begin{align*}
	p_1 &=a_1\\
	c_1 &=f(a_1 \oplus IV)\\
	p_2 &=a_2\\
	c_2 &=f(a_2 \oplus c_1)\\
	&\ldots\\
	c_4 &=f(a_4 \oplus c_3)
	\end{align*}
	%%%End of Old Def
}
We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
first using repeated applications of $h()$ to first encode
the position of that character in the string. For example,
$h^1(a_1), ~h^2(a_2), ~h^3(a_3), h^4(a_4)$.
We then combine each character in the string via $\oplus$,
$h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4)$. 


\subsubsection{String Index and Cypher Block Encoding}

For example, consider the string ``$a_1a_2a_3a_4$'' and assume
this string is contained in the ith block of the CPC problem.
We then introduce a new nonce $r_i$ which will be added to ensure
only strings with the same index can be unified. 
The encoding is done as follows:
\begin{itemize}
		\item $p_1 = 0$
		\item $c_1 = f(0 \oplus IV) = f(IV)$. 
		Note, that this cypher block is 
		not unifiable with any other due to the unique IV.
		\item $p_2 = r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4) \oplus c_1$
		\item $c_2 = f(r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4) \oplus c_1 \oplus c_1) = 
		f(r_1 \oplus h^1(a_1) \oplus h^2(a_2) \oplus h^3(a_3) \oplus h^4(a_4))$. 
\end{itemize} 


\subsubsection{Chaining Multiple String}
Suppose we want to now encode the new string $A_1 A_3$.
This encoding can be done as follows:
\begin{itemize}
	\item Encode the character positions using $h()$ in
	$A_1$ concatenated with $A_2$. 
	Denote these as $h(A_1A_3)$
	respectively. 
	\item Create a sessions, and remove the initial IV.
	\item Encode the string into a cypher block and add 
	a new nonce the represents the index $1,3$, denotes this
	nonce as $r_{13}$.
	\begin{itemize}
		\item $p_2= r_{1,3} \oplus h(A_1 A_3) \oplus c_1$
		\item $c_2 = f(r_{1,3} \oplus h(A_1 A_3))$
	\end{itemize} 
\end{itemize}

\subsubsection{Encoding all Possible Permutations}
We now have all the tools needed to encode the possible 
strings that can be formed from the strings of a PCP.\\
	Steps:
	\begin{enumerate}
		\item We start with two sets of sessions, one for the 
		$A$ strings of the PCP, and one for the $B$ strings.
		\item Each string is encoded in the method described above.
		\item Remove the initial oracle introduced IV from each 
		session. 
		\item After encoding one or more strings we add a special 
		nonce to the end of the strings that encodes the index's of the strings concatenated together. The nonce used 
		to encode the index in the $A$ strings must be the same nonce
		for the same index in the $B$ strings. For example, 
		$A_1A_3$ use the nonce '$13$', and $B_1B_3$ would use the same
		nonce '$13$'. In this way only encodings of the $A$ strings with the same nonce as those strings in $B$ could be unified.
		\item After encoding an index, check if the cypher block can be unified. If yes, then stop. If not, remove the nonce, as described above. Start new sessions, one for each new index. 
		For example, if you encoded $A_1$, you would then create 
		sessions for $A_1A_1$ and sessions for 
		$A_1A_2$ and $A_1A_3$. 
	\end{enumerate}

Notice that any possible string formed from the initial PCP strings 
can be encoded into a cypher block. Only those blocks sharing the
same index nonce from the $A$ strings and $B$ strings can be unified.
If there is a unifier there is a solution to the PCP. 



\subsection{Arbitrary Sessions of Arbitrary Length}
The next problem to consider is the opposite extreme, that of unbounded
number of sessions and an unbounded session length.
 

\begin{theorem}\label{thm:unbounded_unbounded}
The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
sessions, unbounded session lengths, immediate schedule, and CBC. 
\end{theorem}
\begin{proof}\todo{Andrew: Need to improve the proof}
	\textit{Claim 1:} These exists a unifier to two cypher blocks
	of the MOE program described in Section~\ref{sec:encoding} iff
	there is a solution to the corresponding PCP.
	\noindent
	\text{Claim Proof Sketch:}\\
	If there is a unifier it has to be between two string encoded 
	with the same index from the upper and lower parts of the PCP
	due to the unique nonces encoding the index and the position encoding.
	IF there is a solution to the PCP, that solution will evidentially
	be encoded into two sessions that are unifiablee. 
\end{proof}

\begin{example}
	Consider the following PCP:
	\[
	(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
	\]
	The solution for this basic PCP problem is $1,3$.
	
	We would start with two sets of sessions, one for the 
	upper strings. $ba, ~ab, ~aaa$, and one for the lower
	strings, $baa, ~ba, ~aa$. One session for each of the initial strings. 
	
	\noindent
	$A$ Sessions:
	\begin{enumerate}
		\item Session1, string ``ba'':
		\begin{align*}
		p_1 &= 0\\
		c^{A1}_1 &= f(0 \oplus IV_{1})\\
		p_2 &= r_1 \oplus h(b) \oplus h^2(a) \oplus c^{A1}_1\\
		c^{A1}_2 &= f(r_1 \oplus h(b) \oplus h^2(a) \oplus c^{A1}_1 \oplus c^{A1}_1) = f(r_1 \oplus h(b) \oplus h^2(a))
		\end{align*}
		\item Session2, string ``ab'':
		\begin{align*}
			c^{A2}_2 &=f(r_2 \oplus h(a) \oplus h^2(b))
		\end{align*}
		\item Session3, string ``aaa'':
		\begin{align*}
			c^{A3}_2 &=f(r_3 \oplus h(a) \oplus h^2(a) \oplus h^3(a))
		\end{align*}
	\end{enumerate}
	
	\noindent
	$B$ Sessions:
\begin{enumerate}
	\item Session1, string ``baa'':
	\begin{align*}
	c^{B1}_2 &= f(r_1 \oplus h(b) \oplus h^2(a) \oplus h^3(a))
	\end{align*}
	\item Session2, string ``ba'':
	\begin{align*}
	c^{B2}_2 &= f(r_2 \oplus h(b) \oplus h^2(a))
	\end{align*}
	\item Session3, string ``aa'':
	\begin{align*}
	c^{B3}_2 &= f(r_3 \oplus h(a) \oplus h^2(a))
	\end{align*}
\end{enumerate}
 
Now try if we look for unifiers of the above cypher blocks, 
$c^{A1}_2, ~c^{A2}_2, ~c^{A3}_2, ~c^{B1}_2, ~c^{B2}_2, ~c^{B3}_2$.
We don't find a unifier so we move on to test the next level of
possible strings, those with index: $11, 12, 13, 21, 22, 23, 31, 32, 33$. For these we first remove the current nonce encoding an index, 
then concatenate the two strings, and then add the new nonce for the
new index.  To save space we will just show this process for 
the index $1,3$ (the solution) for the $A$ sessions and the $B$ sessions.

SessionA, string `$A_1A_2 = ba \cdot aaa$:
\begin{align*}
p_1 &= 0\\
c^{A}_1 &= f(0 \oplus IV_{1})\\
p_2 &= r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a) \oplus c^{A}_1\\
c^{A}_2 &= f(r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a))\\
\end{align*}
SessionB, string `$B_1B_2 = baa \cdot aa$:
\begin{align*}
p_1 &= 0\\
c^{B}_1 &= f(0 \oplus IV_{2})\\
p_2 &= r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a) \oplus c^{B}_1\\
c^{B}_2 &= f(r_{13} \oplus h(b) \oplus h^2(a) \oplus h^3(a) \oplus h^4(a) \oplus h^5(a))\\
\end{align*}

Now if we check for unifiers we find one for $c^{A}_2$ and 
$c^{B}_2$, which corresponds to the PCP solution $1,3$.
 
 
\end{example}


\subsubsection{Finite Length with Arbitrary Sessions}

\begin{lemma}\label{lemma:sim_arbitrary_length}
Given a $MOE_{\oplus}$ program with sessions of fixed length,
sessions of arbitrary length can be simulated provided 
an arbitrary number of sessions can be created. 	
\end{lemma}
\begin{proof}
Suppose there is a bound, $n$, on the length of a sessions, 
i.e., the number of cypher blocks per session. Suppose you wanted to continue a session beyond the bound, create a $c_{n+1}$ from 
a $c_{n}$. You need to create a new sessions, remove the 
new $IV$ (as is done above), add $c_{n}$, and continue. 
Provided you have an arbitrary number of sessions this can continue
providing arbitrary length for sessions. 
\end{proof}

\begin{theorem}\label{thm:bounded_unbounded}
The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
sessions, bounded session lengths, immediate schedule, and CBC.	
\end{theorem}
\begin{proof}
	From Lemma~\ref{lemma:sim_arbitrary_length} 
	and Theorem~\ref{thm:unbounded_unbounded}.
\end{proof}

\subsubsection{Finite Sessions of Arbitrary Length}
\begin{lemma}\label{lemma:sim_arbitrary_sessions}
	Given a $MOE_{\oplus}$ program with sessions of arbitrary length
	and a bounded number of sessions,
	an unbounded number of sessions can be simulated. 	
\end{lemma}
\begin{proof}
	Suppose there is a bound, $n$, on the number of sessions. Suppose you wanted to create a new, $n+1$, session. We can add a new
	session to an existing one by doing the following: 
	remove the old cypher block, add a random nonce, and the 
	first plain text of the new session. Notice if you want to 
	continue the old session, just repeat the steps but add 
	the old cypher test as the first plain text.  
\end{proof}  

 
 \begin{theorem}\label{thm:unbounded_bounded}
 	The $MOE_{\oplus}$ decision problem is undecidable for bounded 
 	sessions, unbounded session lengths, immediate schedule, and CBC.	
 \end{theorem}
 \begin{proof}
 	From Lemma~\ref{lemma:sim_arbitrary_sessions} 
 	and Theorem~\ref{thm:unbounded_unbounded}.
 \end{proof}
 



\end{document}