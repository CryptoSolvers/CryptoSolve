\documentclass{llncs}

\usepackage{amssymb}
\usepackage{proof}
%\usepackage{hyperref}
\usepackage{url}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{latexsym, graphics, graphicx}
\usepackage{color}
\usepackage{epsfig, amssymb}
\usepackage{yfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{float}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{marginnote}
\usepackage{mathtools}
\usepackage{todonotes}



\newtheorem{assumption}{Assumption}

\newcommand{\pa}{{\bf Pair}}
\newcommand{\enc}{{\bf Enc}}
\newcommand{\eq}{\mathcal{EQ}}
\newcommand{\bphi}{\ovr{\phi}}
\newcommand{\bh}{\ovr{h}}
\newcommand{\tdh}{\tilde{h}}
\newcommand{\ignore}[1]{}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}

%\newcommand{\ISFULL}

\ifdefined\ISFULL
\newcommand{\FULL}[1]{#1}
\newcommand{\SHORT}[1]{}
\else
\newcommand{\FULL}[1]{}
\newcommand{\SHORT}[1]{#1}
\fi



\title{ $MOE$ Decision Problems}


\pagestyle{empty}

\begin{document}

\maketitle
\begin{abstract}
The $MOE$ decision problem. 

\end{abstract}

\section{Definitions}

\begin{definition}
	$MOE$-terms: Given a first-order signature $\Sigma$, a countable set of (free) constants (names) $N$, such that $\Sigma \cap N =\emptyset$, and a (countable) set of variables $X$, the set of $MOE$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$. 
\end{definition}



\begin{definition}
	$MOE$-Program: Is an interaction between the 
	the adversary and the oracle consisting of the following actions
	and orders. Let $c$ be a name representing a session identifier.
	\begin{enumerate}
		\item $start(c)$. The start of a session $c$, sent from the
		adversary to oracle.
		\item $stop(c)$. The end of session $c$.
		\item $block(c, x)$. A new block in session $c$ sent from
		the adversary to the oracle. This is to be encrypted by the 
		oracle. This variable, $x$, represents possible messages, via
		instantiation, that the adversary could send during a program
		run. 
		\item $send(c, m)$. The oracle send a $MOE$-term, $m$, back
		to the adversary. The variables of $m$ must have been 
		previously contained in a received $block(c, x)$ message
		that occurred before the $send(c, m)$ message.
	\end{enumerate} 
\end{definition}
This ordering in the last item will be important to the decision 
problems. We can more compactly represent the sequence of messages
in a $MOE$-program as a frame. 

\begin{definition}
		$MOE$-frame:  $\phi = \nu \tilde{n}.\sigma$, where
		$\tilde{n}$ is a set of names representing non-free variables such as random nonces. $\sigma$ is a substitution
		such that $Dom(\sigma) = \{ y_1, y_2, \ldots, y_n\}$,
		$Dom(\sigma) \cap \tilde{n} = \emptyset$, and
		$Ran(\sigma)$ are $MOE$-terms.  
\end{definition}

A $MOE$-frame models a trace of a $MOE$ program in the following way:
if the $i$th action of the challenger in the trace is 
$Rcv\_Block(t)$ or $Send(t)$, where $t$ is a $MOE$-term, 
then there is a variable $y_i \in Dom(\sigma)$ and 
$y_i \sigma \mapsto t$. Random variables such as the IV are 
modeled as names and placed in $\tilde{n}$.

The terms of the frame are further restricted depending on the mode of encryption being modeled and the schedule used by the oracle to
return cipher blocks to the adversary. These restrictions have
the following impact on the $MOE$-frames:
\begin{itemize}
	\item $MOE$: The mode of encryption dictates how the oracle 
	constructs cypher blocks. For example, in a CyberBlock Chaining,
	$CBC$, $MOE$ the ith block of cipher text, $C_i$, is modeled by
	the $y_i \mapsto f(C_{i-1} \oplus x_i)$, where $\oplus$ is
	the xor function.
	\item Schedule: The oracle can either return the 
	cipher blocks immediately or at the end of the session.  
\end{itemize}

The adversary has the ability to execute multiple simultaneous session with the oracle. In this case the initial name, the IV, will be fresh for each session. Each session can then be modeled by it's own frame. 


%\begin{definition}
%	Let 
%\end{definition}


\section{$MOE$ Decision Problems}

We model a potential attack via a decision problem involving unification. 

First we need a new definition of unification which includes the 
constraint on term orders imposed by the $MOE$-program. This 
ordering can be enforeced using a relation $\prec_{\mathcal{P}}$, defined 
as follows. 

\begin{definition}
	Let $\mathcal{P}$ be a $MOE$-program and $\phi = \nu \tilde{n}.\sigma$ the corresponding frame. We define a relation, 
	$\prec_{\mathcal{P}}$, by:
	\begin{itemize}
		\item $t \prec_{\mathcal{P}} x$,
		$y_i \mapsto x, ~y_j \mapsto t ~ \in \sigma$, and
		$ i < j$.
		\item $x_i \prec_{\mathcal{P}} x_j$ iff 
		 $y_i \mapsto x_i, ~y_j \mapsto x_j ~ \in \sigma$, and
		 $ i < j$.
		 \item If $\bar{t} \prec_{\mathcal{P}} x$, then 
		 $f(\bar{t}) \prec_{\mathcal{P}} x$, where $f \in \Sigma$.
		 \item $t \not \prec_{\mathcal{P}} x$ iff $t \prec_{\mathcal{P}} x$ does not hold.
	\end{itemize}
\end{definition}

We can now define the $MOE$ unification problem.

\begin{definition}
	Let $\mathcal{P}$ be a $MOE$-program and $\phi = \nu \tilde{n}.\sigma$ the corresponding frame. Let $t_1$ and $t_2$
	be two $MOE$-terms appearing in $\mathcal{P}$. $t_1$ and $t_2$
	are $\mathcal{P}$-unifiable iff there exists some substitution
	$\delta$ s.t.
	\begin{itemize}
		\item $\forall x \in Dom(\delta), ~x\delta \prec_{\mathcal{P}} x$.
		\item $t_1 \delta =_E t_2\delta$.
	\end{itemize}
\end{definition}


\begin{definition}\todo[inline]{Andrew: We need to improve this def}
	Decision Problem: We model an attack by the adversary being able
	to unify two terms, either from the same frame of from different
	frames.  
\end{definition}

Now that the general decision problem is defined, we can define several
instances of the problem based on the combination of the following factors:
\begin{itemize}
	\item The equational Theory $E$.
	\item The $MOE$.
	\item The Schedule.
	\item Bounds on the session length and number of sessions.  
\end{itemize}

We consider several of these possibilities in what follows.

First, we will consider the $E=xor$ equational theory and we 
will consider the following $MOE$. In these modes of encryption 
$\Sigma ={\oplus, 0, f}$, where $\oplus$ is xor and $f=enc(K,\_)$.
$IV$ is the initialization vector, the first block sent. 
\begin{itemize}
	\item Cipher Block Chaining $(CBC):$ The ith plain text is modeled via a term consisting of a single variable $x_i$. The initial cipher block, the IV, is modeled by a name, $r$. The ith block of cipher text, $C_i$, is modeled by a
	term $f(C_{i-1} \oplus x_i)$.
	\item Cipher Feedback $(CFB):$ The ith plain text is modeled via a term consisting of a single variable $x_i$. The initial cipher block is modeled by a name, $r$. The ith block of cipher text, $C_i$, is modeled by a
	term $f(C_{i-1}) \oplus x_i$.  
	\item Propagating Cipher Block Chaining ($PCBC$): 
	$C_1 = f(P_1 \oplus IV)$, $C_i = f(P_i \oplus P_{i-1} \oplus C_{i-1})$.
\end{itemize}

\subsubsection{Dealing with $IV$}\label{sec_iv}
We need in several cases to remove the $IV$, either to chain 
sessions without including a new $IV$ or to ensure two 
different sessions have the same fake $IV$. More information on these methods are below. Here we describe how to replace the $IV$ added
to the block $C_1 = (p_1 \oplus IV)$. 
\begin{align*}
	p_1 &= 0\\
	c_1 &= f(0 \oplus IV) = f(IV)\\
	p_2 &= c_1\\
	c_2 &= f(c_1 \oplus c_1) = f(0)
\end{align*}
Notice that if we want to simulate something like an $IV$, but
that we know, we could replace $0$ in the above interaction 
with some nonce $k$. This will be useful when we want two 
sessions to have the same starting nonce. 

\ignore{
\subsection{$MOE_A$ Decision Problems} 
\begin{conjecture}
	Given a signature $\Sigma=\{
	\oplus, f\}$, where $\oplus$ is associative, the $CBC$ MOE, the immediate  schedule, unbounded sessions, and unbounded session 
	length.  The $MOE_A$ decision problem is undecidable.
\end{conjecture}\todo[inline]{Andrew: This is really just a proof sketch and we will need to make sure there isn't a problem.}
\begin{proof}
	Reduction from the PCP. Since $\oplus$ is just $A$ we can directly
	model string by chaining the symbols together via $\oplus$.
	
	For a PCP the adversary starts two classes of sessions. 
	The first class consists of a session for each of the string
	in the upper part of the PCP problem, $A_1, A_2, \ldots, A_n$.
	The second class consists of a session for each of the strings
	in the lower part of the PCP problems, $B_1, B_2, \ldots, B_n$.
	
	The adversary simulates each possible index (and thus possible PCP
	solution) by creating a session for each index in each class, A and B. To ensure each session in A are only unified with index in B
	the adversary uses a unique IV for each index in A that matches the same index in B. 
	
	Since there is in bound on the session length
	or the number of sessions if there is a solution, the index of that
	solution in the A set of index will be unified with the same index in the B set. Since unification is modulo $A$ there is then a solution to the PCP problem.  
\end{proof}
}
\subsection{$MOE_{\oplus}$ Decision Problems}
We will first consider the xor equational theory. We can therefore refine the definition of $MOE$-term 
 
\begin{definition}
	$MOE_{\oplus}$-terms: Given a first-order signature $\Sigma=\{
	\oplus, 0, f\}$, a countable set of (free) constants (names) $N$, such that $\Sigma \cap N =\emptyset$, and a (countable) set of variables $X$, the set of $MOE_{\oplus}$-terms over $X$ is denoted by $T(\Sigma \cup N,X)$. 
\end{definition}

\subsubsection{Finite Sessions of Finite Length}
The first decision problem to consider is the $MOE_{\oplus}$
problem with a finite bound on both the number of sessions and
the sessions lengths. 
For both schedules and both $MOE$s, $CBC$ and $CFB$, the problem
reduces to the $MOE$-unification problem for $E=xor$. This problem
has been solved in the positive [Chris and Hia Paper].

\subsubsection{Arbitrary Sessions of Arbitrary Length}
The next problem to consider is the opposite extreme, that of unbounded
number of sessions and an unbounded session length. 

\begin{theorem}\label{thm:unbounded_unbounded}
The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
sessions, unbounded session lengths, immediate schedule, and CBC. 
\end{theorem}
\begin{proof}
\textbf{Proof Sketch}:\\
Consider an arbitrary PCP problem:
\[
(\frac{A_1}{B_1}),~(\frac{A_2}{B_2}), ~\ldots, ~(\frac{A_n}{B_n})
\]
over an alphabet $\Sigma=\{a, b\}$. 
\begin{itemize}
	\item Encoding strings:\\ 
	We encode a string a string $A_i = a_1 a_2 a_3 a_4$ by 
	setting each character of the string as a plaintext block 
	and sending each to the oracle from left to right, one at a 
	time. For example,  $A_i = a_1 a_2 a_3 a_4$:
	\begin{align*}
	p_1 &=a_1\\
	c_1 &=f(a_1 \oplus IV)\\
	p_2 &=a_2\\
	c_2 &=f(a_2 \oplus c_1)\\
	&\ldots\\
	c_4 &=f(a_4 \oplus c_3)
	\end{align*}
	\item Removing and replacing the IV:
	The $IV$ can be removed and replaced with $f(D)$ for 
	some nonce $D$. See section~\ref{sec_iv} for more details.
	\item Chaining multiple strings:\\
	We also need to chain together the encodings of two or more strings. For example, if we wanted to encode $A_1A_2$. We
	could just encode them in the same session but it will be
	useful below to start a new session when concatenating 
	a string onto the end of another string. We do this as 
	follows:
	\begin{itemize}
		\item Suppose we have two string $A_1 = a_{11}a_{12}$, and 
		$A_2 =a_{21}a_{22}$.
		\item Encoding the first string we get 
		$c^1_2 = f(a_{12} \oplus f(a_{11}\oplus IV))$.
		\item Start a second session and remove the $IV$:
		\begin{align*}
		c^2_1 &= f(0 \oplus IV) = f(IV)\\
		c^2_2 &= f(c^2_1 \oplus c^2_1) = f(0)\\
		c^2_3 &= f(a_{21} \oplus c^1_2 \oplus c^2_2 \oplus c^2_2) =
		f(a_{21} \oplus c^1_2)
		\end{align*}
	\end{itemize} 
	\item Adding/Removing a final nonce to encode the index:
	After we have encoded one or more strings together we can 
	add a nonce that is used to indicate the index of the encoded
	strings and there order. For example, if we encode $A_1A_3$, 
	we can add a nonce, '$13$' to a final cypher block. Notice
	when we encode $B_1B_3$ we can add the same final nonce. This
	ensures that only strings with the same index could possibly 
	be unified since only these strings will have matching final 
	nonces. 
	
	nonces can then be removes by applying the same method above.
	This allows us to remove a nonce, concatenate another string 
	onto the encoding, add a new nonce indicating the new index, 
	test for unifiability. 
	\item Encoding all possible permutations:\\
	We now have all the tools needed to encode the possible 
	strings that can be formed from the strings of a PCP.\\
	Steps:
	\begin{enumerate}
		\item We start with two sets of sessions, one for the 
		$A$ strings of the PCP, and one for the $B$ strings.
		\item Each string is encoded in the method described above.
		\item Remove the initial oracle introduced IV from each 
		session. 
		\item After encoding one or more strings we add a special 
		nonce to the end of the strings that encodes the index of the 
		index of the strings concatenated together. The nonce used 
		to encode the index in the $A$ strings must be the same nonce
		for the same index in the $B$ strings. For example, 
		$A_1A_3$ use the nonce '$13$', and $B_1B_3$ would use the same
		nonce '$13$'. In this way only encodings of the $A$ strings with the same nonce as those strings in $B$ could be unified.
		\item After encoding a an index, check if the cypher block can be unified. If yes, then stop. If not, remove the nonce, as described above. Start new sessions, one for each new index. 
		For example, if you encoded $A_1$, you would then continue this
		sessions for $A_1A_1$ and start two new sessions for 
		$A_1A_2$ and $A_1A_3$. 
	\end{enumerate}
\end{itemize}
Notice that any possible string formed from the initial PCP strings 
can be encoded into a cypher block. Only those blocks sharing the
same index nonce from the $A$ strings and $B$ strings can be unified.
If there is a unifier there is a solution to the PCP. 
\end{proof}


\begin{example}
	Consider the following PCP:
	\[
	(\frac{ba}{baa}),~(\frac{ab}{ba}),~(\frac{aaa}{aa})
	\]
	The solution for this basic PCP problem is $1,3$.
	
	We would start with two sets of sessions, one for the 
	upper strings. $ba, ~ab, ~aaa$, and one for the lower
	strings, $baa, ~ba, ~aa$. One session for each of the initial strings. 
	
	\noindent
	$A$ Sessions:
	\begin{enumerate}
		\item Session1, string ``ba'':
		\begin{align*}
		p_1 &= 0\\
		c^{A1}_1 &= f(0 \oplus IV_{1})\\
		p_2 &= b \oplus c^{A1}_1\\
		c^{A1}_2 &= f(b \oplus c^{A1}_1 \oplus c^{A1}_1)\\
		p_3 &= a\\
		c^{A1}_3 &= f(a \oplus c^{A1}_2)\\
		&\text{Add the nonce for the index, 1 in this case}\\
		c^{A1}_4 &=f(1, \oplus c^{A1}_3)
		\end{align*}
		\item Session2, string ``ab'':
		\begin{align*}
		c^{A2}_3 &= f(b \oplus c^{A2}_2)\\
			&\text{Add the nonce for the index, 2 in this case}\\
			c^{A2}_4 &=f(2, \oplus c^{A2}_3)
		\end{align*}
		\item Session3, string ``aaa'':
		\begin{align*}
		c^{A3}_4 &= f(a \oplus c^{A3}_3)\\
			&\text{Add the nonce for the index, 3 in this case}\\
			c^{A3}_5 &=f(3, \oplus c^{A3}_4)
		\end{align*}
	\end{enumerate}
	
	\noindent
	$B$ Sessions:
\begin{enumerate}
	\item Session1, string ``baa'':
	\begin{align*}
	c^{B1}_4 &= f(a \oplus c^{B1}_3)\\
		&\text{Add the nonce for the index, 1 in this case}\\
		c^{B1}_5 &=f(1, \oplus c^{B1}_4)
	\end{align*}
	\item Session2, string ``ba'':
	\begin{align*}
	c^{B2}_3 &= f(a \oplus c^{B2}_2)\\
		&\text{Add the nonce for the index, 2 in this case}\\
		c^{B2}_4 &=f(2, \oplus c^{B2}_3)
	\end{align*}
	\item Session3, string ``aa'':
	\begin{align*}
	c^{B3}_3 &= f(a \oplus c^{B3}_2)\\
		&\text{Add the nonce for the index, 3 in this case}\\
		c^{B3}_4 &=f(3, \oplus c^{B3}_3)
	\end{align*}
\end{enumerate}
 
Now try if we look for unifiers of the above cypher blocks, 
$c^{A1}_4, ~c^{A2}_4, ~c^{A3}_5, ~c^{B1}_5, ~c^{B2}_4, ~c^{B3}_4$.
We don't find a unifier so we move on to test the next level of
possible strings, those with index: $11, 12, 13, 21, 22, 23, 31, 32, 33$. For these we first remove the current nonce encoding an index, 
then concatenate the two strings, and then add the new nonce for the
new index.  To save space we will just show this process for 
the index 1,3 (the solution) for the $A$ session.

Session1, string ``ba'':
\begin{align*}
p_1 &= 0\\
c^{A1}_1 &= f(0 \oplus IV_{1})\\
p_2 &= b \oplus c^{A1}_1\\
c^{A1}_2 &= f(b \oplus c^{A1}_1 \oplus c^{A1}_1)\\
p_3 &= a\\
c^{A1}_3 &= f(a \oplus c^{A1}_2)\\
&\text{Add the nonce for the index, 1 in this case}\\
c^{A1}_4 &=f(1, \oplus c^{A1}_3)\\
&\text{end of encoding of string 1, ``ba''}\\
&\text{start a new session to add string ''aaa''}\\
p_1 &= 0\\
c^{A1,3}_1 &= f(0 \oplus IV)\\
p_2 &= a \oplus c^{A1}_3 \oplus c^{A1,3}_1\\
c^{A1,3}_2 &= f(a \oplus c^{A1}_3 \oplus c^{A1,3}_1 \oplus c^{A1,3}_1 ) = \\ f(a \oplus c^{A1}_3) \\
&\ldots \\
c^{A1,3}_4 &= f(a \oplus c^{A1,3}_3) \\
&\text{Add the new index 1,3}\\
c^{A1,3}_5 &= f(13 \oplus c^{A1,3}_4) \\
\end{align*}
Notice that for the string in the $B$ sessions with index $1,3$ we get
$c^{B1,3}_5 = f(13 \oplus c^{B1,3}_4)$.

Now if we check for unifiers we find one for $c^{A1,3}_5$ and 
$c^{B1,3}_5$, which corresponds to the PCP solution $1,3$.
 
 
\end{example}


\subsubsection{Finite Length with Arbitrary Sessions}

\begin{lemma}\label{lemma:sim_arbitrary_length}
Given a $MOE_{\oplus}$ program with sessions of fixed length,
sessions of arbitrary length can be simulated provided 
an arbitrary number of sessions can be created. 	
\end{lemma}
\begin{proof}
Suppose there is a bound, $n$, on the length of a sessions, 
i.e., the number of cypher blocks per session. Suppose you wanted to continue a session beyond the bound, create a $c_{n+1}$ from 
a $c_{n}$. You need to create a new sessions, remove the 
new $IV$ (as is done above), add $c_{n}$, and continue. 
Provided you have an arbitrary number of sessions this can continue
providing arbitrary length for sessions. 
\end{proof}

\begin{theorem}\label{thm:bounded_unbounded}
The $MOE_{\oplus}$ decision problem is undecidable for unbounded 
sessions, bounded session lengths, immediate schedule, and CBC.	
\end{theorem}
\begin{proof}
	From Lemma~\ref{lemma:sim_arbitrary_length} 
	and Theorem~\ref{thm:unbounded_unbounded}.
\end{proof}

\subsubsection{Finite Sessions of Arbitrary Length}
\begin{lemma}\label{lemma:sim_arbitrary_sessions}
	Given a $MOE_{\oplus}$ program with sessions of arbitrary length
	and a bounded number of sessions,
	an unbounded number of sessions can be simulated. 	
\end{lemma}
\begin{proof}
	Suppose there is a bound, $n$, on the number of sessions. Suppose you wanted to create a new, $n+1$, session. We can add a new
	session to an existing one by doing the following: 
	remove the old cypher block, add a random nonce, and the 
	first plain text of the new session. Notice if you want to 
	continue the old session, just repeat the steps but add 
	the old cypher test as the first plain text.  
\end{proof}  

 
 \begin{theorem}\label{thm:unbounded_bounded}
 	The $MOE_{\oplus}$ decision problem is undecidable for bounded 
 	sessions, unbounded session lengths, immediate schedule, and CBC.	
 \end{theorem}
 \begin{proof}
 	From Lemma~\ref{lemma:sim_arbitrary_sessions} 
 	and Theorem~\ref{thm:unbounded_unbounded}.
 \end{proof}


\end{document}