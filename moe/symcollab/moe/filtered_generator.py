"""
Creates filtered modes of operations that can be later used in a MOOProgram.
"""
from symcollab.algebra import Constant, Function, FuncTerm, Variable, Term
from .generator import MOOGenerator

__all__ = ['FilteredMOOGenerator']

class FilteredMOOGenerator(MOOGenerator):
    """
    Filters out modes of operation generated by MOOGenerator.

    Parameters
    ==========
    max_history: int
      The maximum number of past cipher blocks to consider for
      constructing a mode of operation.
    max_f_depth: int
      The maximum amount of nested encryption applications.
    requires_iv: bool
      Whether or not the initialization vector is required to be in
      the mode of operation.
    requires_chaining: bool
      Whether or not a previous ciphertext must appear in a mode
      of operation.
    """
    def __init__(self, max_history: int = 4, max_f_depth: int = 3,
                 requires_iv: bool = False, requires_chaining: bool = False):
        MOOGenerator.__init__(self, max_history, max_f_depth)
        self.max_history = max_history #maximum x for every i-x
        self.max_f_depth = max_f_depth #maximum number of nested f's
        self.requires_iv = requires_iv
        self.requires_chaining = requires_chaining


    def __next__(self):
        term = MOOGenerator.__next__(self)
        while not self._conditions_met(term):
            term = MOOGenerator.__next__(self)
        return term

    def _conditions_met(self, term: Term) -> bool:
        """Given a term, state whether the conditions are met."""
        if _f_depth(term) > self.max_f_depth:
            return False

        if self.requires_chaining and not _satisfies_chaining(term, self.max_history):
            return False

        if self.requires_iv and Constant("r") not in term:
            return False

        # Passes all conditions
        return True


def _f_depth(term: Term) -> int:
    """Returns the maximum depth of nested f terms."""
    if isinstance(term, FuncTerm) and term.function.arity > 0:
        if term.function == Function("f", 1):
            return 1 + _f_depth(term.arguments[0])
        return max((_f_depth(t) for t in term.arguments))
    return 0

def _satisfies_chaining(term: Term, max_history: int):
    """Checks to see if a preivous ciphertext is in the term."""
    previous_ciphertexts = [Variable("C[i-" + str(i + 1) + "]") for i in range(max_history)]
    previous_ciphertexts_in_term = [(ci in term) for ci in previous_ciphertexts]
    return any(previous_ciphertexts_in_term)
