from copy import deepcopy
from symcollab.algebra import *
import numpy as np # type: ignore
from sympy.solvers.diophantine import diophantine # type: ignore
from sympy import symbols # type: ignore
from sympy.solvers.diophantine import diop_linear # type: ignore
from sympy.parsing.sympy_parser import parse_expr # type: ignore
from collections import Counter

def occurs_check(U: set):
	for e in U:
		if isinstance(e.left_side, Variable) and isinstance(e.right_side, FuncTerm):
			if e.left_side in e.right_side:
				print('Occurs Check')
				return False
		if isinstance(e.right_side, Variable) and isinstance(e.left_side, FuncTerm):
			if e.right_side in e.left_side:
				print('Occurs Check')
				return False

	for e in U:
		if isinstance(e.left_side, Variable) and isinstance(e.right_side, FuncTerm):
			for e2 in U:
				if e.left_side != e2.left_side:
					if isinstance(e2.left_side, Variable) and isinstance(e2.right_side, FuncTerm):
						if e.left_side in e2.right_side:
							if occurs_check2(U, 0, e, e2):
								print('Occurs Check')
								return False

def occurs_check2(U: set, depth, e, e2):
	if depth > len(U)
		return False

	for e3 in U:
		if e3.left_side != e2.left_side and e3.left_side != e.left_side:
			if isinstance(e3.left_side, Variable) and isinstance(e3.right_side, FuncTerm):
				if e2.left_side in e3.right_side:
					if e3.right_side in e.left_side:
						return True:
					else:
						if occurs_check2(U, depth+1, e, e3):
							return True
			else if isinstance(e3.left_side, Variable) and isinstance(e3.right_side, Variable):
				if occurs_check2(U, depth+1, e, e3):
							return True